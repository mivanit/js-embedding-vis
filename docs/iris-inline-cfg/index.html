<!DOCTYPE html>
<!-- source repo: https://github.com/mivanit/js-embedding-vis -->
<!-- version: v0.1.0 -->
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1.0" />
	<title>Embedding Explorer</title>
	<!-- favicon -->
		<!-- begin 'favicon.svg' -->
	<link rel="icon" type="image/svg" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ij4KICA8IS0tIEJhY2tncm91bmQgLS0+CiAgPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSIjMDAwMDExIi8+CiAgCiAgPCEtLSAzRCBjb29yZGluYXRlIGF4ZXMgLS0+CiAgPGxpbmUgeDE9IjgiIHkxPSI4IiB4Mj0iNCIgeTI9IjEyIiBzdHJva2U9IiM0NDQ0ZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxsaW5lIHgxPSI4IiB5MT0iOCIgeDI9IjgiIHkyPSIxIiBzdHJva2U9IiM0NGZmNDQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPiAgCiAgPGxpbmUgeDE9IjgiIHkxPSI4IiB4Mj0iMTUiIHkyPSI4IiBzdHJva2U9IiNmZjQ0NDQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIAogIDwhLS0gRGF0YSBwb2ludHMgc2NhdHRlcmVkIGluIDNEIHNwYWNlIC0tPgogIDxjaXJjbGUgY3g9IjExIiBjeT0iMyIgcj0iMS4yIiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iOCIgY3k9IjEzIiByPSIxIiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMSIgcj0iMS4yIiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iNCIgY3k9IjkiIHI9IjAuOCIgZmlsbD0iIzAwZmYwMCIvPgogIDxjaXJjbGUgY3g9IjMiIGN5PSIzIiByPSIxIiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iMTIiIGN5PSI2IiByPSIwLjgiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+">
	<!-- end 'favicon.svg' -->
	<!-- libraries -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<!-- styles -->
		<!-- begin 'style.css' -->
	<style>
	/* Base styles */
	body {
		margin: 0;
		padding: 0;
		background: #000;
		font-family: 'Courier New', monospace;
		overflow: hidden;
	}
	
	#container {
		position: relative;
		width: 100vw;
		height: 100vh;
	}
	
	/* Shortcuts panel (top-right) */
	#shortcuts {
		position: absolute;
		top: 20px;
		right: 20px;
		background: rgba(0, 0, 0, 0.7);
		padding: 10px;
		border-radius: 8px;
		color: #00ff00;
		z-index: 100;
		font-size: 12px;
		line-height: 1.4;
	}
	
	#shortcuts div {
		margin-bottom: 2px;
		display: flex;
		justify-content: space-between;
		align-items: center;
	}
	
	#shortcuts div:last-child {
		margin-bottom: 0;
	}
	
	/* Menu base styles */
	.menu {
		position: absolute;
		background: rgba(0, 0, 0, 0.8);
		padding: 15px;
		border-radius: 8px;
		color: #00ff00;
		z-index: 100;
		display: none;
	}
	
	/* Specific menu positions */
	#helpMenu {
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		min-width: 350px;
	}
	
	#controlsMenu {
		top: 20px;
		left: 20px;
	}
	
	#statsMenu {
		top: 50%;
		right: 20px;
		transform: translateY(-50%);
		min-width: 200px;
	}
	
	#infoMenu {
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		min-width: 300px;
		max-width: 400px;
		max-height: 40vh;
		overflow-y: auto;
	}
	
	#legendMenu {
		bottom: 20px;
		left: 20px;
		min-width: 300px;
		max-height: 60vh;
		overflow-y: auto;
	}
	
	#navbar {
		bottom: 20px;
		right: 20px;
		padding: 12px 15px;
		font-size: 11px;
		min-width: 160px;
		line-height: 1.3;
	}
	
	/* Navball styles */
	#navball-container {
		width: 150px;
		height: 150px;
		border: 2px solid #00ff00;
		border-radius: 50%;
		position: relative;
		background: radial-gradient(circle, #001122 0%, #000000 100%);
		margin: 0 auto 10px auto;
	}
	
	#navball-canvas {
		border-radius: 50%;
	}
	
	.navball-crosshair {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 12px;
		height: 12px;
		pointer-events: none;
		z-index: 10;
	}
	
	.navball-crosshair::before {
		content: '';
		position: absolute;
		top: 50%;
		left: 0;
		width: 100%;
		height: 1px;
		background: #ffff00;
		transform: translateY(-50%);
	}
	
	.navball-crosshair::after {
		content: '';
		position: absolute;
		left: 50%;
		top: 0;
		width: 1px;
		height: 100%;
		background: #ffff00;
		transform: translateX(-50%);
	}
	
	/* New layout helpers for side-by-side sections */
	.control-section {
		margin-bottom: 15px;
	}
	
	.control-section h4 {
		margin: 0 0 10px 0;
		color: #00ccff;
		font-size: 12px;
		font-weight: bold;
	}
	
	.side-by-side {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 15px;
	}
	
	.side-by-side-triple {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr;
		gap: 12px;
	}
	
	/* Column selection side-by-side layout */
	.column-selection {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 15px;
	}
	
	.column-item {
		display: flex;
		flex-direction: column;
	}
	
	.column-item label {
		margin-bottom: 5px;
		font-size: 12px;
		color: #00ccff;
	}
	
	.column-item select {
		width: 100%;
		background: #333;
		color: #00ff00;
		border: 1px solid #555;
		padding: 5px;
		border-radius: 3px;
		margin-bottom: 5px;
	}
	
	/* Point configuration sections */
	.point-config {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}
	
	.point-config h5 {
		margin: 0 0 8px 0;
		color: #00ccff;
		font-size: 11px;
		font-weight: bold;
		text-align: center;
	}
	
	/* Axis selection layout */
	.axis-selection {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr;
		gap: 12px;
	}
	
	.axis-item {
		display: flex;
		flex-direction: column;
	}
	
	.axis-item label {
		margin-bottom: 5px;
		font-size: 11px;
		color: #00ccff;
		text-align: center;
	}
	
	.axis-item select {
		width: 100%;
		background: #333;
		color: #00ff00;
		border: 1px solid #555;
		padding: 4px;
		border-radius: 3px;
		margin-bottom: 5px;
		font-size: 11px;
	}
	
	/* Control groups and sections */
	.control-group {
		margin-bottom: 10px;
	}
	
	.control-row {
		display: flex;
		align-items: center;
		margin-bottom: 8px;
		gap: 10px;
	}
	
	.control-row label {
		flex: 0 0 80px;
		font-size: 11px;
		margin: 0;
	}
	
	.control-row input[type="range"] {
		flex: 1;
		margin: 0 5px;
	}
	
	.control-row .value-display {
		flex: 0 0 40px;
		text-align: center;
		font-size: 11px;
	}
	
	.control-row input[type="color"] {
		width: 30px;
		height: 20px;
		padding: 0;
		border: none;
		border-radius: 3px;
	}
	
	.help-section,
	.stats-group,
	.nav-section {
		margin-bottom: 15px;
	}
	
	.help-section:last-child,
	.stats-group:last-child,
	.nav-section:last-child {
		margin-bottom: 0;
	}
	
	.help-section h3,
	.stats-group h3 {
		margin: 0 0 8px 0;
		color: #00ccff;
		font-size: 12px;
	}
	
	.nav-section h4 {
		margin: 0 0 3px 0;
		color: #00ccff;
		font-size: 10px;
		font-weight: bold;
	}
	
	.help-section p,
	.stats-group p {
		margin: 0 0 5px 0;
		font-size: 12px;
	}
	
	.stats-group p {
		font-size: 11px;
	}
	
	/* Navigation rows */
	.nav-row {
		display: flex;
		justify-content: space-between;
		margin-bottom: 2px;
	}
	
	.nav-row:last-child {
		margin-bottom: 0;
	}
	
	/* Form elements */
	label {
		display: block;
		margin-bottom: 5px;
		font-size: 12px;
	}
	
	input[type="range"] {
		width: 100%;
		background: #333;
		color: #00ff00;
		border: 1px solid #555;
		padding: 5px;
		height: 20px;
	}
	
	.dropdown-container {
		position: relative;
		margin-bottom: 10px;
	}
	
	.dropdown-container label {
		display: block;
		margin-bottom: 5px;
		font-size: 12px;
		color: #00ccff;
	}
	
	.dropdown-container select {
		width: 100%;
		background: #333;
		color: #00ff00;
		border: 1px solid #555;
		padding: 5px;
		border-radius: 3px;
	}
	
	/* Updated button styling to match theme better */
	button {
		margin-top: 5px;
		padding: 6px 12px;
		background: #2a4a2a;
		color: #00ff00;
		border: 1px solid #00ff00;
		border-radius: 4px;
		cursor: pointer;
		font-family: 'Courier New', monospace;
		font-size: 11px;
		transition: all 0.2s;
	}
	
	button:hover {
		background: #00ff00;
		color: #000;
	}
	
	/* Special button for randomize colors */
	.randomize-btn {
		background: #2a2a4a;
		border-color: #4444ff;
		color: #4444ff;
	}
	
	.randomize-btn:hover {
		background: #4444ff;
		color: #fff;
	}
	
	/* Export config button styling */
	.export-btn {
		background: #4a2a4a;
		border-color: #ff4444;
		color: #ff4444;
		width: 100%;
		padding: 8px;
	}
	
	.export-btn:hover {
		background: #ff4444;
		color: #fff;
	}
	
	/* Legacy button class for compatibility */
	.color-randomize-btn {
		background: #2a4a2a;
		border: 1px solid #00ff00;
		color: #00ff00;
		padding: 6px 12px;
		border-radius: 4px;
		font-size: 11px;
		cursor: pointer;
		margin-top: 5px;
		font-family: 'Courier New', monospace;
		transition: all 0.2s;
	}
	
	.color-randomize-btn:hover {
		background: #00ff00;
		color: #000;
	}
	
	/* Display elements */
	.value-display {
		display: inline-block;
		float: right;
		font-weight: bold;
	}
	
	.close-hint {
		text-align: center;
		margin-top: 15px;
		font-size: 11px;
		color: #888;
	}
	
	/* Interactive elements */
	.shortcut-link {
		cursor: pointer;
		transition: color 0.2s;
	}
	
	.shortcut-link:hover {
		color: #00ccff;
	}
	
	.status-indicator {
		font-size: 10px;
		margin-left: 8px;
	}
	
	.status-enabled {
		color: #00ff00;
	}
	
	.status-disabled {
		color: #ff4444;
	}
	
	/* Hover panel */
	.hover-panel {
		position: absolute;
		display: none;
		min-width: 250px;
		max-width: 350px;
		font-size: 12px;
		pointer-events: none;
		padding: 6px;
		color: #ffffff;
		background: rgba(0, 0, 0, .8);
		border: 1px solid #555;
	}
	
	/* Legend and value grid items */
	.legend-item {
		display: flex;
		align-items: center;
		margin-bottom: 4px;
		font-size: 11px;
	}
	
	.legend-color {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		margin-right: 6px;
		flex-shrink: 0;
	}
	
	.value-grid-item {
		display: flex;
		align-items: center;
		padding: 2px 4px;
		border-radius: 2px;
		font-size: 10px;
		color: white;
		cursor: pointer;
		margin: 1px 0;
		transition: background-color 0.2s;
		position: relative;
	}
	
	.value-grid-item:hover {
		filter: brightness(1.2);
	}
	
	.value-grid-item.selected {
		box-shadow: 0 0 3px #ffff00;
	}
	
	.value-grid-color {
		width: 8px;
		height: 8px;
		border-radius: 1px;
		margin-right: 4px;
		flex-shrink: 0;
	}
	
	.legend-item-clickable {
		cursor: pointer;
	}
	
	.legend-item-clickable:hover {
		filter: brightness(1.3);
	}
	
	.remove-btn {
		margin-left: auto;
		color: #ff4444;
		cursor: pointer;
		font-weight: bold;
		padding: 2px 6px;
		font-size: 14px;
		line-height: 1;
		border-radius: 2px;
		transition: all 0.2s;
		min-width: 20px;
		text-align: center;
		flex-shrink: 0;
	}
	
	.remove-btn:hover {
		background-color: #ff4444;
		color: white;
		transform: scale(1.1);
	}
	
	/* Colorbar styles */
	.colorbar {
		height: 20px;
		width: 100%;
		background: linear-gradient(to right, #440154, #31688e, #35b779, #fde725);
		border-radius: 3px;
		margin: 5px 0;
	}
	
	.colorbar-labels {
		display: flex;
		justify-content: space-between;
		font-size: 10px;
		margin-top: 2px;
	}
	
	/* New control row layout for sliders */
	.control-row-new {
		display: flex;
		flex-direction: column;
		margin-bottom: 8px;
		gap: 5px;
	}
	
	.control-row-new label {
		display: flex;
		justify-content: space-between;
		align-items: center;
		font-size: 11px;
		margin: 0;
	}
	
	.value-display-right {
		font-weight: bold;
		color: #00ff00;
		min-width: 40px;
		text-align: right;
	}
	
	.slider-container {
		width: 80%;
		margin: 0 auto;
	}
	
	.slider-container input[type="range"] {
		width: 100%;
		margin: 0;
	}
	
	/* Loading indicator */
	.loading-indicator {
		position: fixed;
		top: 20px;
		left: 50%;
		transform: translateX(-50%);
		background: rgba(0, 34, 68, 0.95);
		color: #00ff00;
		padding: 12px 24px;
		border-radius: 8px;
		font-family: 'Courier New', monospace;
		font-size: 12px;
		font-weight: bold;
		z-index: 1001;
		display: none;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		border: 1px solid #00ff00;
		min-width: 200px;
		text-align: center;
	}
	
	.loading-indicator.visible {
		display: block;
	}
	
	.loading-spinner {
		display: inline-block;
		width: 12px;
		height: 12px;
		border: 2px solid #004400;
		border-radius: 50%;
		border-top-color: #00ff00;
		animation: spin 1s ease-in-out infinite;
		margin-right: 8px;
		vertical-align: middle;
	}
	
	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}
	
	.loading-progress {
		margin-top: 4px;
		font-size: 10px;
		color: #00ccff;
	}
	
	/* Info box popup styles (middle-click) */
	.info-box {
		position: fixed;
		background: rgba(0, 0, 0, 0.9);
		border: 2px solid #ffff00;
		border-radius: 6px;
		padding: 6px;
		color: #00ff00;
		font-family: 'Courier New', monospace;
		font-size: 11px;
		z-index: 1000;
		cursor: move;
		user-select: none;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
	}
	
	.info-box-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 4px;
	}
	
	.info-box-title {
		color: #00ccff;
		font-size: 11px;
		cursor: pointer;
	}
	
	.info-box-title:hover {
		text-decoration: underline;
	}
	
	.info-box-close {
		color: #ff4444;
		cursor: pointer;
		font-weight: bold;
		font-size: 14px;
		line-height: 1;
		margin-left: 8px;
	}
	
	.info-box-close:hover {
		color: #ff6666;
	}
	
	.info-box-content {
		color: #00ff00;
	}
	
	.info-box-content img {
		max-width: 100%;
		height: auto;
		display: block;
	}
	
	/* SVG overlay for info box connection lines */
	#info-box-lines {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 999;
	}
	
	.info-box-line {
		stroke: #ffff00;
		stroke-width: 2;
		stroke-opacity: 0.7;
		fill: none;
	}
	
	.info-box-anchor {
		fill: #ffff00;
		fill-opacity: 0.8;
	}
	</style>
	<!-- end 'style.css' -->
		<!-- begin 'notif.css' -->
	<style>
	/* Notification system styling */
	.notification-container {
	    position: fixed;
	    top: 0;
	    left: 50%;
	    transform: translateX(-50%);
	    z-index: 1001;
	    pointer-events: none;
	}
	
	.notification-indicator {
	    position: absolute;
	    left: 50%;
	    transform: translateX(-50%);
	    background: rgba(0, 34, 68, 0.95);
	    color: #00ff00;
	    padding: 12px 24px;
	    border-radius: 8px;
	    font-family: 'Courier New', monospace;
	    font-size: 12px;
	    font-weight: bold;
	    display: block;
	    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	    border: 1px solid #00ff00;
	    min-width: 200px;
	    text-align: center;
	    transition: all 0.3s ease;
	    opacity: 1;
	    margin-bottom: 10px;
	}
	
	/* Success styling */
	.notification-indicator.success {
	    background: rgba(0, 68, 34, 0.95);
	    border-color: #00ff88;
	    color: #00ff88;
	}
	
	/* Error styling */
	.notification-indicator.error {
	    background: rgba(68, 0, 0, 0.95);
	    border-color: #ff4444;
	    color: #ff4444;
	}
	
	/* Loading spinner */
	.notification-spinner {
	    display: inline-block;
	    width: 12px;
	    height: 12px;
	    border: 2px solid #004400;
	    border-radius: 50%;
	    border-top-color: #00ff00;
	    animation: spin 1s ease-in-out infinite;
	    margin-right: 8px;
	    vertical-align: middle;
	}
	
	.notification-indicator.success .notification-spinner {
	    border-color: #004400;
	    border-top-color: #00ff88;
	}
	
	.notification-indicator.error .notification-spinner {
	    display: none;
	    /* No spinner for errors */
	}
	
	/* Progress bar components */
	.notification-progress-container {
	    width: 100%;
	    height: 6px;
	    background: rgba(255, 255, 255, 0.1);
	    border-radius: 3px;
	    margin-top: 8px;
	    overflow: hidden;
	}
	
	.notification-progress-bar {
	    height: 100%;
	    background: #00ff00;
	    border-radius: 3px;
	    transition: width 0.3s ease;
	    width: 0%;
	}
	
	.notification-indicator.success .notification-progress-bar {
	    background: #00ff88;
	}
	
	.notification-indicator.error .notification-progress-bar {
	    background: #ff4444;
	}
	
	@keyframes spin {
	    to {
	        transform: rotate(360deg);
	    }
	}
	
	/* Hide spinner when not in spinner mode */
	.notification-indicator:not(.spinner) .notification-spinner {
	    display: none;
	}
	</style>
	<!-- end 'notif.css' -->
	<!-- code -->
		<!-- begin 'config.js' -->
	<script>
	var INLINE_CONFIG = null; // For inline config overrides
	
	var INLINE_CONFIG = {
  "dataFile": null,
  "numericalPrefix": "pc.",
  "defaultColorColumn": "target_name",
  "defaultSelectionColumn": "target_name",
  "hoverColumns": [
    "target_name",
    "data.sepal length (cm)",
    "data.sepal width (cm)",
    "data.petal length (cm)",
    "data.petal width (cm)"
  ],
  "selectedPoints": {
    "size": 5,
    "sizeMin": 0.1,
    "sizeMax": 20,
    "sizeStep": 0.1,
    "opacityMin": 0.0,
    "opacityStep": 0.01
  },
  "nonSelectedPoints": {
    "size": 3,
    "sizeMin": 0.1,
    "sizeStep": 0.1,
    "opacityMin": 0.0
  },
  "movement": {
    "speed": 25,
    "speedMin": 1,
    "rollSpeed": 0.02,
    "mouseSensitivity": 0.002,
    "sprintMultiplier": 3
  },
  "camera": {
    "position": {
      "z": 5
    }
  },
  "data": [
    {
      "pc.1": -2.6841256259695383,
      "pc.2": 0.31939724658508517,
      "pc.3": -0.027914827589424318,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.7141416872943243,
      "pc.2": -0.1770012250648012,
      "pc.3": -0.21046427237822485,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.8889905690592954,
      "pc.2": -0.1449494260855726,
      "pc.3": 0.017900256320896868,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.7,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.745342855641408,
      "pc.2": -0.3182989792519315,
      "pc.3": 0.03155937360567984,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.6,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.728716536554532,
      "pc.2": 0.3267545129349072,
      "pc.3": 0.09007924055118122,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.6,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.280859632844497,
      "pc.2": 0.7413304490629082,
      "pc.3": 0.16867765820907715,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.9,
      "data.petal length (cm)": 1.7,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.820537750740608,
      "pc.2": -0.0894613845285761,
      "pc.3": 0.2578921582556134,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.6,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.6261449731466335,
      "pc.2": 0.16338495969831257,
      "pc.3": -0.02187931788673203,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.8863827317805497,
      "pc.2": -0.5783117541867195,
      "pc.3": 0.020759570264794136,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.4,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.6727557978209533,
      "pc.2": -0.1137742458741382,
      "pc.3": -0.19763272498815176,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.1
    },
    {
      "pc.1": -2.5069470906518596,
      "pc.2": 0.6450688986485575,
      "pc.3": -0.07531800937914335,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.7,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.612755230908723,
      "pc.2": 0.014729939161362005,
      "pc.3": 0.10215025995656601,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.8,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.7861092661880162,
      "pc.2": -0.23511200020173995,
      "pc.3": -0.2068444304496393,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.8,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.1
    },
    {
      "pc.1": -3.2238037438656493,
      "pc.2": -0.5113945870063983,
      "pc.3": 0.061299672457111654,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.3,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.1,
      "data.petal width (cm)": 0.1
    },
    {
      "pc.1": -2.6447503899420366,
      "pc.2": 1.1787646364375561,
      "pc.3": -0.15162752361782417,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 4.0,
      "data.petal length (cm)": 1.2,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.386039033531141,
      "pc.2": 1.338062330400648,
      "pc.3": 0.2777769027030938,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 4.4,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.6235278752244313,
      "pc.2": 0.8106795141812491,
      "pc.3": 0.1381832278807174,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.9,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.648296706254383,
      "pc.2": 0.31184914459334134,
      "pc.3": 0.026668315612594418,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.1998203236175855,
      "pc.2": 0.8728390389621952,
      "pc.3": -0.12030552339475531,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 1.7,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.5879863998787718,
      "pc.2": 0.5135603087492688,
      "pc.3": 0.21366517222468928,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.3102562152425206,
      "pc.2": 0.39134593565387377,
      "pc.3": -0.2394440432449686,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.7,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.543705228757159,
      "pc.2": 0.4329960632790213,
      "pc.3": 0.2084572324167066,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.7,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -3.215939415648612,
      "pc.2": 0.13346806953851686,
      "pc.3": 0.2923967507452383,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.6,
      "data.sepal width (cm)": 3.6,
      "data.petal length (cm)": 1.0,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.302733182226208,
      "pc.2": 0.0987088548140882,
      "pc.3": 0.03912325874289857,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 1.7,
      "data.petal width (cm)": 0.5
    },
    {
      "pc.1": -2.3557540491237727,
      "pc.2": -0.03728185967739339,
      "pc.3": 0.12502108270283574,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.8,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.9,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.5066689069258206,
      "pc.2": -0.14601688049529038,
      "pc.3": -0.25342004234464877,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.4688200731213397,
      "pc.2": 0.1309514894352395,
      "pc.3": 0.09491057609939546,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.5623199061960182,
      "pc.2": 0.3677188574341832,
      "pc.3": -0.07849420513793859,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.2,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.6395347153845443,
      "pc.2": 0.312039980235264,
      "pc.3": -0.14590889573003019,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.2,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.631989387274345,
      "pc.2": -0.19696122492432888,
      "pc.3": 0.040771079067166704,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.7,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.587398476689351,
      "pc.2": -0.20431849127415092,
      "pc.3": -0.07722298907343883,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.8,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.4099324970021776,
      "pc.2": 0.4109242642295561,
      "pc.3": -0.14552497200511083,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.6488623343499174,
      "pc.2": 0.8133638202969538,
      "pc.3": 0.2256691497200523,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.2,
      "data.sepal width (cm)": 4.1,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.1
    },
    {
      "pc.1": -2.5987367491005937,
      "pc.2": 1.0931457594493468,
      "pc.3": 0.15781081295817107,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 4.2,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.636926878105798,
      "pc.2": -0.12132234786588292,
      "pc.3": -0.14304958178613303,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.8662416521186698,
      "pc.2": 0.06936447158005965,
      "pc.3": -0.16433230665300502,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 1.2,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.625238049850376,
      "pc.2": 0.5993700213794018,
      "pc.3": -0.2683503756939304,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.8006841154482234,
      "pc.2": 0.26864373779796935,
      "pc.3": 0.09369908247976633,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 3.6,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.1
    },
    {
      "pc.1": -2.9805020437819905,
      "pc.2": -0.4879583444286295,
      "pc.3": 0.07292704569270592,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.4,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.5900063139680976,
      "pc.2": 0.22904383682699514,
      "pc.3": -0.08008230301733588,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.770102426027903,
      "pc.2": 0.2635275337442442,
      "pc.3": 0.07724769316110836,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.849368705043098,
      "pc.2": -0.9409605736412221,
      "pc.3": -0.34923037730589057,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.5,
      "data.sepal width (cm)": 2.3,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.997406546594905,
      "pc.2": -0.3419260574716212,
      "pc.3": 0.19250921171270935,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.4,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 1.3,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.405614485097487,
      "pc.2": 0.18887142893025555,
      "pc.3": 0.26386794551343445,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.5,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.6
    },
    {
      "pc.1": -2.2094892377836826,
      "pc.2": 0.4366631416391842,
      "pc.3": 0.2987427457550677,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 1.9,
      "data.petal width (cm)": 0.4
    },
    {
      "pc.1": -2.714451426757706,
      "pc.2": -0.2502082041852285,
      "pc.3": -0.09767814404560182,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.8,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.3
    },
    {
      "pc.1": -2.5381482589989433,
      "pc.2": 0.5037711444614272,
      "pc.3": 0.1667056366047605,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 1.6,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.8394621676428486,
      "pc.2": -0.22794556949384148,
      "pc.3": 0.08372684903359151,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 4.6,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.5430857498303965,
      "pc.2": 0.5794100215198741,
      "pc.3": -0.017115024248539057,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.3,
      "data.sepal width (cm)": 3.7,
      "data.petal length (cm)": 1.5,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": -2.70335978233516,
      "pc.2": 0.1077060824993934,
      "pc.3": -0.08929400847882374,
      "target_int": 0,
      "target_name": "setosa",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 1.4,
      "data.petal width (cm)": 0.2
    },
    {
      "pc.1": 1.284825688858347,
      "pc.2": 0.6851604704673022,
      "pc.3": -0.40656802546771387,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 7.0,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 4.7,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 0.9324885323123153,
      "pc.2": 0.31833363826263206,
      "pc.3": -0.01801418664625054,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 1.46430232199139,
      "pc.2": 0.5042628153092004,
      "pc.3": -0.3383257649809125,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.9,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 4.9,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.18331771995837443,
      "pc.2": -0.8279590118206368,
      "pc.3": -0.17959139187531548,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 2.3,
      "data.petal length (cm)": 4.0,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 1.0881032577116647,
      "pc.2": 0.07459067519771256,
      "pc.3": -0.30775789623477123,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.5,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.6,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.641669084258079,
      "pc.2": -0.4182468715686758,
      "pc.3": 0.04107609082393415,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 1.0950606626324442,
      "pc.2": 0.2834682700615403,
      "pc.3": 0.169810239860554,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 4.7,
      "data.petal width (cm)": 1.6
    },
    {
      "pc.1": -0.749122669829652,
      "pc.2": -1.004890961181899,
      "pc.3": 0.012302919237624277,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 2.4,
      "data.petal length (cm)": 3.3,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 1.044131826053433,
      "pc.2": 0.22836189978838828,
      "pc.3": -0.41533608475941086,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.6,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.6,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": -0.008745404082892705,
      "pc.2": -0.7230819050048263,
      "pc.3": 0.281141431176432,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.2,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 3.9,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": -0.5078408838353186,
      "pc.2": -1.2659711905264048,
      "pc.3": -0.2698171827688063,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 2.0,
      "data.petal length (cm)": 3.5,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 0.5116985574475974,
      "pc.2": -0.10398123549903371,
      "pc.3": 0.13054775024049692,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.9,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.2,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.2649765081120492,
      "pc.2": -0.5500364636804953,
      "pc.3": -0.6941468301443935,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 2.2,
      "data.petal length (cm)": 4.0,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 0.9849345104708895,
      "pc.2": -0.12481785412635471,
      "pc.3": -0.06211440832228177,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.7,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": -0.1739253716817668,
      "pc.2": -0.2548542087025867,
      "pc.3": 0.09045769072573073,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 3.6,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.9278607809442443,
      "pc.2": 0.4671794944415053,
      "pc.3": -0.31462097583217297,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 4.4,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 0.6602837616969381,
      "pc.2": -0.3529696657238377,
      "pc.3": 0.328027528378579,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.23610499331767265,
      "pc.2": -0.33361076682492374,
      "pc.3": -0.2711618372510871,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 4.1,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 0.9447337280198163,
      "pc.2": -0.5431455507797773,
      "pc.3": -0.49951904648505885,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.2,
      "data.sepal width (cm)": 2.2,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.04522697629870276,
      "pc.2": -0.583834377471872,
      "pc.3": -0.23500210497204332,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 3.9,
      "data.petal width (cm)": 1.1
    },
    {
      "pc.1": 1.1162831773500494,
      "pc.2": -0.08461685219476855,
      "pc.3": 0.4596209913590962,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.9,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 4.8,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 0.357888417997307,
      "pc.2": -0.06892503165601838,
      "pc.3": -0.22985388760893166,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.0,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 1.298183875358915,
      "pc.2": -0.3277873083339218,
      "pc.3": -0.34785435225729777,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 4.9,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.9217289224470369,
      "pc.2": -0.18273779362137077,
      "pc.3": -0.23107177773632093,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.7,
      "data.petal width (cm)": 1.2
    },
    {
      "pc.1": 0.7148533259114096,
      "pc.2": 0.14905594436977854,
      "pc.3": -0.3218009372444727,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.3,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.900174373172165,
      "pc.2": 0.32850447383431813,
      "pc.3": -0.31620907371157037,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.6,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.4,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 1.3320244367220866,
      "pc.2": 0.24444087601633413,
      "pc.3": -0.5217027796644221,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.8,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.8,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 1.5578021550660681,
      "pc.2": 0.2674954473102584,
      "pc.3": -0.16492098374357878,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.0,
      "data.petal width (cm)": 1.7
    },
    {
      "pc.1": 0.8132906498175414,
      "pc.2": -0.16335030068761114,
      "pc.3": 0.03542450484616133,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": -0.3055837780243076,
      "pc.2": -0.36826218975459923,
      "pc.3": -0.31849158062302463,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 2.6,
      "data.petal length (cm)": 3.5,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": -0.06812649206836063,
      "pc.2": -0.7051721317994746,
      "pc.3": -0.2442138104335313,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 2.4,
      "data.petal length (cm)": 3.8,
      "data.petal width (cm)": 1.1
    },
    {
      "pc.1": -0.18962247237849894,
      "pc.2": -0.6802867635281444,
      "pc.3": -0.30642056121764005,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 2.4,
      "data.petal length (cm)": 3.7,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 0.13642871155801561,
      "pc.2": -0.31403243824924143,
      "pc.3": -0.17724276601122946,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 3.9,
      "data.petal width (cm)": 1.2
    },
    {
      "pc.1": 1.3800264359155117,
      "pc.2": -0.42095428731387496,
      "pc.3": 0.016167127520716584,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 1.6
    },
    {
      "pc.1": 0.5880064433398653,
      "pc.2": -0.48428741998120284,
      "pc.3": 0.4444334986397867,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.4,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.8068583125004096,
      "pc.2": 0.19418231471316716,
      "pc.3": 0.38896306309818807,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.6
    },
    {
      "pc.1": 1.2206908824443499,
      "pc.2": 0.4076195936110061,
      "pc.3": -0.23716700988388417,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 4.7,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 0.8150952357666013,
      "pc.2": -0.3720370599095162,
      "pc.3": -0.6147208425917884,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.3,
      "data.petal length (cm)": 4.4,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.24595767988669337,
      "pc.2": -0.26852439662200833,
      "pc.3": 0.1883668116461819,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.1,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.1664132171454602,
      "pc.2": -0.6819267248636276,
      "pc.3": -0.0600092258553121,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 4.0,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.46480028840378207,
      "pc.2": -0.67071154451172,
      "pc.3": -0.024306855718969622,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.5,
      "data.sepal width (cm)": 2.6,
      "data.petal length (cm)": 4.4,
      "data.petal width (cm)": 1.2
    },
    {
      "pc.1": 0.8908151984694488,
      "pc.2": -0.03446444436826468,
      "pc.3": -0.00994693289437043,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.6,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 0.23054802355945725,
      "pc.2": -0.40438584800733146,
      "pc.3": -0.22941024143914124,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.6,
      "data.petal length (cm)": 4.0,
      "data.petal width (cm)": 1.2
    },
    {
      "pc.1": -0.7045317592446585,
      "pc.2": -1.012248227531722,
      "pc.3": -0.10569114890298126,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.0,
      "data.sepal width (cm)": 2.3,
      "data.petal length (cm)": 3.3,
      "data.petal width (cm)": 1.0
    },
    {
      "pc.1": 0.35698149470104923,
      "pc.2": -0.5049100933371076,
      "pc.3": 0.01661717019826725,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 4.2,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.3319344799450592,
      "pc.2": -0.21265468378116736,
      "pc.3": 0.08320429089564874,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.2,
      "data.petal width (cm)": 1.2
    },
    {
      "pc.1": 0.376215651066671,
      "pc.2": -0.2932189292514158,
      "pc.3": 0.07799635108766612,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.2,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 0.6425760075543367,
      "pc.2": 0.0177381901124134,
      "pc.3": -0.20539496698326454,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 6.2,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 4.3,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": -0.9064698649488321,
      "pc.2": -0.7560933665990195,
      "pc.3": -0.012599647557832605,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.1,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 3.0,
      "data.petal width (cm)": 1.1
    },
    {
      "pc.1": 0.29900084187814446,
      "pc.2": -0.34889780645033497,
      "pc.3": 0.010581660495574519,
      "target_int": 1,
      "target_name": "versicolor",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.1,
      "data.petal width (cm)": 1.3
    },
    {
      "pc.1": 2.531192727803626,
      "pc.2": -0.009849109498764719,
      "pc.3": 0.7601654272458918,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 6.0,
      "data.petal width (cm)": 2.5
    },
    {
      "pc.1": 1.4152358767039042,
      "pc.2": -0.5749163475464725,
      "pc.3": 0.29632252738798087,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 1.9
    },
    {
      "pc.1": 2.6166760159956866,
      "pc.2": 0.34390315134174543,
      "pc.3": -0.11078788321911004,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.1,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.9,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 1.9715310530434351,
      "pc.2": -0.17972790435223285,
      "pc.3": 0.10842466246339455,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.350005920044639,
      "pc.2": -0.040260947142509274,
      "pc.3": 0.28538956318444275,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.5,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.8,
      "data.petal width (cm)": 2.2
    },
    {
      "pc.1": 3.397038736053254,
      "pc.2": 0.550836673028062,
      "pc.3": -0.348437555797501,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.6,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 6.6,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 0.5212322439097798,
      "pc.2": -1.1927587270006264,
      "pc.3": 0.5456592956468362,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 4.9,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 4.5,
      "data.petal width (cm)": 1.7
    },
    {
      "pc.1": 2.9325870689936853,
      "pc.2": 0.3555000029774975,
      "pc.3": -0.420239935768017,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.3,
      "data.sepal width (cm)": 2.9,
      "data.petal length (cm)": 6.3,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.3212288165733774,
      "pc.2": -0.24383150231068917,
      "pc.3": -0.34830439493484844,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 5.8,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.9167509667860667,
      "pc.2": 0.7827919488153077,
      "pc.3": 0.4233354176825505,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.2,
      "data.sepal width (cm)": 3.6,
      "data.petal length (cm)": 6.1,
      "data.petal width (cm)": 2.5
    },
    {
      "pc.1": 1.6617741536365287,
      "pc.2": 0.24222840775508292,
      "pc.3": 0.24244018972577897,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.5,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 1.8034019529650909,
      "pc.2": -0.21563761733354792,
      "pc.3": -0.03764816823146422,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 5.3,
      "data.petal width (cm)": 1.9
    },
    {
      "pc.1": 2.165591796080143,
      "pc.2": 0.21627558507403855,
      "pc.3": 0.03332664184434231,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.8,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.5,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 1.3461635794584552,
      "pc.2": -0.7768183473443235,
      "pc.3": 0.2819028821185102,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.7,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 5.0,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 1.585928223873224,
      "pc.2": -0.5396407140266897,
      "pc.3": 0.6290293264080761,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 2.4
    },
    {
      "pc.1": 1.9044563747934253,
      "pc.2": 0.11925069209199712,
      "pc.3": 0.4796398196266188,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 5.3,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.9496890593990672,
      "pc.2": 0.04194325966322232,
      "pc.3": 0.04418616763009797,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.5,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.5,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 3.4870553642902706,
      "pc.2": 1.1757393297134513,
      "pc.3": 0.1338948739360164,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.7,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 6.7,
      "data.petal width (cm)": 2.2
    },
    {
      "pc.1": 3.795645422072882,
      "pc.2": 0.25732297342048405,
      "pc.3": -0.5137677638178043,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.7,
      "data.sepal width (cm)": 2.6,
      "data.petal length (cm)": 6.9,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.3007917126376602,
      "pc.2": -0.7611496364350678,
      "pc.3": -0.3449950383134005,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 2.2,
      "data.petal length (cm)": 5.0,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 2.4278179130660424,
      "pc.2": 0.37819601261707003,
      "pc.3": 0.21911932430195852,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.9,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 5.7,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.1990011054655625,
      "pc.2": -0.6060915277579086,
      "pc.3": 0.5118555086970294,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.6,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.9,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 3.499920038924534,
      "pc.2": 0.4606740989118947,
      "pc.3": -0.5731822425680374,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.7,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 6.7,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 1.3887661316914652,
      "pc.2": -0.20439932735214583,
      "pc.3": -0.06452275663123819,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 4.9,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.275430503872202,
      "pc.2": 0.33499060582169804,
      "pc.3": 0.28615009116913076,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 5.7,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 2.614090473810826,
      "pc.2": 0.5609013551230833,
      "pc.3": -0.20553452435367736,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.2,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 6.0,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 1.2585081605114876,
      "pc.2": -0.17970479472273837,
      "pc.3": 0.04584770392727722,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.2,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 4.8,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 1.2911320591150206,
      "pc.2": -0.11666865117399716,
      "pc.3": 0.23125646265997457,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.9,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.123608722773895,
      "pc.2": -0.20972947667728725,
      "pc.3": 0.1541800239288446,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 2.3880030160034638,
      "pc.2": 0.46463980470873434,
      "pc.3": -0.449530191941898,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.2,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.8,
      "data.petal width (cm)": 1.6
    },
    {
      "pc.1": 2.8416727781038684,
      "pc.2": 0.3752691671951034,
      "pc.3": -0.49889807587078405,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.4,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 6.1,
      "data.petal width (cm)": 1.9
    },
    {
      "pc.1": 3.2306736614320837,
      "pc.2": 1.3741650867930595,
      "pc.3": -0.1145482054754986,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.9,
      "data.sepal width (cm)": 3.8,
      "data.petal length (cm)": 6.4,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 2.15943764248905,
      "pc.2": -0.21727757866903108,
      "pc.3": 0.2087631671308634,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 2.2
    },
    {
      "pc.1": 1.4441612423295096,
      "pc.2": -0.14341341045757883,
      "pc.3": -0.1532338880631131,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.8,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 1.5
    },
    {
      "pc.1": 1.7812948100451136,
      "pc.2": -0.4999016810781347,
      "pc.3": -0.1728751891134772,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.1,
      "data.sepal width (cm)": 2.6,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 1.4
    },
    {
      "pc.1": 3.0764999316871826,
      "pc.2": 0.6880856775711832,
      "pc.3": -0.3355922924345178,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 7.7,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 6.1,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 2.14424331430208,
      "pc.2": 0.14006420108982454,
      "pc.3": 0.734878936725515,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 2.4
    },
    {
      "pc.1": 1.9050981488140737,
      "pc.2": 0.049300526013043466,
      "pc.3": 0.1621802357707035,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.4,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 5.5,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 1.1693263393414997,
      "pc.2": -0.1649902620230943,
      "pc.3": 0.28183584020848895,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.0,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 4.8,
      "data.petal width (cm)": 1.8
    },
    {
      "pc.1": 2.1076111432572393,
      "pc.2": 0.37228787196081026,
      "pc.3": 0.0272911321416498,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.9,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 5.4,
      "data.petal width (cm)": 2.1
    },
    {
      "pc.1": 2.314154705235598,
      "pc.2": 0.1836512791690419,
      "pc.3": 0.32269374717309385,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 5.6,
      "data.petal width (cm)": 2.4
    },
    {
      "pc.1": 1.9222678009025982,
      "pc.2": 0.4092034668160771,
      "pc.3": 0.1135865957994171,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.9,
      "data.sepal width (cm)": 3.1,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.4152358767039042,
      "pc.2": -0.5749163475464725,
      "pc.3": 0.29632252738798087,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.8,
      "data.sepal width (cm)": 2.7,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 1.9
    },
    {
      "pc.1": 2.563013375077473,
      "pc.2": 0.2778626029292175,
      "pc.3": 0.2925695245967426,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.8,
      "data.sepal width (cm)": 3.2,
      "data.petal length (cm)": 5.9,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 2.4187461827328223,
      "pc.2": 0.30479819785472184,
      "pc.3": 0.5044826639772058,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.3,
      "data.petal length (cm)": 5.7,
      "data.petal width (cm)": 2.5
    },
    {
      "pc.1": 1.944109794546967,
      "pc.2": 0.18753230280062283,
      "pc.3": 0.1778250906327135,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.7,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.2,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.5271666148145187,
      "pc.2": -0.3753169825804825,
      "pc.3": -0.12189817186713303,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.3,
      "data.sepal width (cm)": 2.5,
      "data.petal length (cm)": 5.0,
      "data.petal width (cm)": 1.9
    },
    {
      "pc.1": 1.7643457170444279,
      "pc.2": 0.07885885451848917,
      "pc.3": 0.1304816312878655,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.5,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.2,
      "data.petal width (cm)": 2.0
    },
    {
      "pc.1": 1.9009416142184223,
      "pc.2": 0.11662795851205665,
      "pc.3": 0.7232515634899201,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 6.2,
      "data.sepal width (cm)": 3.4,
      "data.petal length (cm)": 5.4,
      "data.petal width (cm)": 2.3
    },
    {
      "pc.1": 1.3901888619479141,
      "pc.2": -0.28266093799053227,
      "pc.3": 0.3629096480853625,
      "target_int": 2,
      "target_name": "virginica",
      "data.sepal length (cm)": 5.9,
      "data.sepal width (cm)": 3.0,
      "data.petal length (cm)": 5.1,
      "data.petal width (cm)": 1.8
    }
  ]
};
	
	
	/* global, mutable CONFIG + helper to merge an optional config.json */
	function getDefaultConfig() {
		let default_cfg = {
			// Data loading
			dataFile: "pca.jsonl",
			numericalPrefix: "pc.",
			defaultColorColumn: "activation.model",
			defaultSelectionColumn: "activation.model",
			hoverColumns: ["activation.cls", "activation.prompt"],
	
			// Selected values
			selectedValues: [],
	
			// UI panel visibility
			panels: {
				help: false,
				menu: false,
				info: false,
				legend: true,
				navbar: true,
				stats: false
			},
	
			// Default axis configuration
			axes: {
				x: 0,
				y: 1,
				z: 2
			},
	
			// Point appearance - selected points
			selectedPoints: {
				size: 6,
				sizeMin: 1,
				sizeMax: 20,
				sizeStep: 1,
				opacity: 1.0,
				opacityMin: 0.1,
				opacityMax: 1.0,
				opacityStep: 0.1
			},
	
			// Point appearance - non-selected points
			nonSelectedPoints: {
				size: 4,
				sizeMin: 1,
				sizeMax: 20,
				sizeStep: 1,
				opacity: 0.25,
				opacityMin: 0.01,
				opacityMax: 1.0,
				opacityStep: 0.01,
				color: "#666666"
			},
	
			// Movement settings
			movement: {
				speed: 50,
				speedMin: 1,
				speedMax: 200,
				speedStep: 1,
				rollSpeed: 0.02,
				mouseSensitivity: 0.002,
				sprintMultiplier: 3
			},
	
			// Interaction settings
			interaction: {
				hoverActive: true,
				selectOnClick: true,
				rightClickActive: true,
				raycastThreshold: 0.15,
				raycastThresholdMultiplier: 3
			},
	
			// Performance settings
			performance: {
				fpsThreshold: 15,
				performanceCheckInterval: 2000,
				performanceWarningDuration: 4000,
				performanceOptimizationCooldown: 30000
			},
	
			// Rendering settings
			rendering: {
				clearColor: "#000011",
				cameraFov: 75,
				cameraNear: 0.1,
				cameraFar: 2000,
				antialiasing: true
			},
	
			// Camera settings
			camera: {
				position: { x: 0, y: 0, z: 0 },
				rotation: { pitch: 0, yaw: 0, roll: 0 }
			},
	
			// Cross-hair settings
			crosshair: {
				color: 0xffff00,
				opacity: 0.4,
				length: 1000
			},
	
			// Navball settings
			navball: {
				size: 150,
				sensitivity: 0.01,
				sphereDetail: { widthSegments: 12, heightSegments: 8 },
				axisLength: 1.3,
				arrowLength: 0.1,
				arrowRadius: 0.02,
				labelScale: 0.3
			},
	
			// Color palette settings
			colors: {
				paletteSize: 128,
				nullValueColor: "#4d4d4d", // Dark gray for null values
				viridisColors: {
					// Viridis colormap coefficients for better performance
					r: [0.267004, 0.105010, 0.330010, 2.437600, -5.179800, 2.066100],
					g: [0.004874, 0.406910, 1.193600, -1.375200, 0.813500, -0.073200],
					b: [0.329415, 0.718080, -0.724400, 0.063300, 0.016700, 0.000000]
				}
			},
	
			// Legend and info panel settings
			ui: {
				maxCategoricalDisplay: 15,
				maxSelectedDisplay: 20,
				hoverOffset: { x: 15, y: 15 },
				shortcutStatusUpdateDelay: 100,
				menuWidth: 350
			},
			// Right-click behavior configuration
			rightClick: {
				mode: "content", // "content" or "url"
	
				// For content mode - creates a new tab with plain text content
				content: {
					title: "Point Data: {activation.cls}",
					template: "Point Information\n===================\n\nClass: {activation.cls}\nModel: {activation.model}\nPrompt: {activation.prompt}\nCoordinates:\n  X ({axis.x.name}): {coord.x}\n  Y ({axis.y.name}): {coord.y}\n  Z ({axis.z.name}): {coord.z}\nConfiguration:\n  Data File: {config.dataFile}\n  Color By: {config.defaultColorColumn}\n  Select By: {config.defaultSelectionColumn}"
				},
				// For URL mode - opens a URL constructed from template
				url: {
					template: "https://example.com/{activation.cls}/{activation.model}?prompt={activation.prompt}&x={coord.x}&y={coord.y}&z={coord.z}"
				}
			},
	
			// Middle-click info box configuration
			middleClick: {
				enabled: true,
				// Title template for the info box header
				title: "{activation.cls}",
				// HTML content template - fully customizable
				// Use {_index} for point index, useful for image filenames
				content: '<div style="max-width: 300px; max-height: 300px; overflow: auto;"><pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">{activation.cls}</pre></div>'
			},
	
			info: {
				title: "Embedding Explorer",
				help: "This tool lets you visualize high-dimensional data in 3D space."
			},
	
			// Highlight groups - custom groups to highlight via URL or config
			// Format: { groupName: { col: "columnName", values: ["val1", "val2"], color: "#ff0000" } }
			highlightGroups: {},
		}
	
		if (INLINE_CONFIG) {
			// If INLINE_CONFIG is set, merge it into the default config
			deepMerge(default_cfg, INLINE_CONFIG);
			console.log("Merged inline config overrides");
		}
		return default_cfg;
	}
	
	let CONFIG = getDefaultConfig();
	let LOADED_CONFIG = null; // Store the config as loaded from file for comparison
	let URL_UPDATE_TIMEOUT = null;
	
	
	/**
	 * Load config.json (if present) and merge into CONFIG.
	 * Also parse URL parameters and apply them to CONFIG.
	 * Priority: URL params > config.json > defaults
	 * @returns {Promise<object>} resolved CONFIG object
	 */
	async function getConfig() {
		try {
			// First, try to load config.json
			const r = await fetch("config.json");
			if (r.ok) {
				const loaded = await r.json();
				// Deep merge loaded config into CONFIG
				deepMerge(CONFIG, loaded);
				// Store a deep copy of the loaded config for URL comparison
				LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
				console.log("Loaded config.json");
			} else {
				console.warn("config.json not found, using defaults");
				// If no config.json, use defaults for comparison
				LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
			}
		} catch (e) {
			// if the inline config is null, then failing to find config.json is fine
			if (!INLINE_CONFIG) {
				console.error("Config load error:", e);
			} else {
				console.warn("Failed to load config.json, but it's fine because an inline config was provided");
			}
			// On error, use defaults for comparison
			LOADED_CONFIG = JSON.parse(JSON.stringify(CONFIG));
		}
	
		// Parse URL parameters and override CONFIG values (highest priority)
		parseURLParams();
	
		return CONFIG;
	}
	
	/**
	 * Deep merge source object into target object
	 */
	function deepMerge(target, source) {
		for (const key in source) {
			if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
				if (!target[key]) target[key] = {};
				deepMerge(target[key], source[key]);
			} else {
				target[key] = source[key];
			}
		}
	}
	
	/**
	 * Parse URL parameters and update CONFIG
	 * Supports nested paths like: ?axes.x=2&selectedPoints.size=8&panels.menu=true
	 * Also supports arrays like: ?selectedValues=value1,value2,value3
	 * Also supports highlight groups like: ?highlight.group1.col=colname&highlight.group1.values=val1,val2
	 */
	function parseURLParams() {
		const params = new URLSearchParams(window.location.search);
	
		// First pass: collect highlight group parameters
		const highlightParams = new Map(); // groupName -> {col, values, color}
	
		for (const [key, value] of params) {
			if (key.startsWith('highlight.')) {
				// Parse: highlight.groupname.property
				const parts = key.split('.');
				if (parts.length === 3) {
					const [, groupName, property] = parts;
					if (!highlightParams.has(groupName)) {
						highlightParams.set(groupName, {});
					}
					const group = highlightParams.get(groupName);
	
					if (property === 'col') {
						group.col = value;
					} else if (property === 'values') {
						group.values = value.split(',').map(v => v.trim());
					} else if (property === 'color') {
						group.color = value;
					}
				}
			} else {
				// Existing behavior for non-highlight params
				setNestedConfigValue(CONFIG, key, parseConfigValue(value));
			}
		}
	
		// Merge collected highlight groups into CONFIG
		for (const [groupName, groupConfig] of highlightParams) {
			if (groupConfig.col && groupConfig.values) {
				CONFIG.highlightGroups[groupName] = groupConfig;
				console.log(`URL param override: highlight group "${groupName}" = col:${groupConfig.col}, values:[${groupConfig.values.join(',')}]${groupConfig.color ? ', color:' + groupConfig.color : ''}`);
			}
		}
	}
	
	/**
	 * Set a nested configuration value using dot notation
	 * Example: setNestedConfigValue(CONFIG, "axes.x", 2)
	 */
	function setNestedConfigValue(obj, path, value) {
		const keys = path.split('.');
		let current = obj;
	
		for (let i = 0; i < keys.length - 1; i++) {
			const key = keys[i];
			if (!(key in current) || typeof current[key] !== 'object') {
				current[key] = {};
			}
			current = current[key];
		}
	
		const finalKey = keys[keys.length - 1];
		current[finalKey] = value;
		console.log(`URL param override: ${path} = ${value}`);
	}
	
	/**
	 * Parse a string value from URL params into appropriate type
	 * Handles arrays (comma-separated values)
	 */
	function parseConfigValue(value) {
		// Boolean
		if (value === 'true') return true;
		if (value === 'false') return false;
	
		// Array (comma-separated) - but handle single values too
		if (value.includes(',')) {
			return value.split(',').map(v => v.trim()).filter(v => v.length > 0);
		}
	
		// Number
		if (!isNaN(value) && !isNaN(parseFloat(value))) {
			return parseFloat(value);
		}
	
		// String (including hex colors) - treat single values as arrays for selectedValues
		return value;
	}
	
	/**
	 * Update the URL with current CONFIG state
	 * Debounced to avoid excessive URL updates
	 */
	function updateURL() {
		if (URL_UPDATE_TIMEOUT) {
			clearTimeout(URL_UPDATE_TIMEOUT);
		}
	
		URL_UPDATE_TIMEOUT = setTimeout(() => {
			const params = generateURLParams();
			const newURL = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
			window.history.replaceState({}, '', newURL);
			URL_UPDATE_TIMEOUT = null;
		}, 500); // 500ms debounce
	}
	
	/**
	 * Generate URL search params from current CONFIG state
	 * Only includes values that differ from the loaded config (not defaults)
	 */
	function generateURLParams() {
		if (!LOADED_CONFIG) {
			// Fallback to default config if loaded config not available
			return new URLSearchParams();
		}
	
		const params = new URLSearchParams();
		const differences = findConfigDifferences(CONFIG, LOADED_CONFIG);
	
		for (const [path, value] of differences) {
			// Skip the data field to prevent huge URLs
			if (path === 'data') {
				continue;
			}
	
			// Skip highlightGroups - handled separately below
			if (path.startsWith('highlightGroups')) {
				continue;
			}
	
			// Special handling for arrays
			if (Array.isArray(value)) {
				if (value.length > 0) {
					params.set(path, value.join(','));
				}
			} else {
				params.set(path, value.toString());
			}
		}
	
		// Handle highlightGroups specially with highlight.groupname.property format
		if (CONFIG.highlightGroups) {
			for (const [groupName, groupConfig] of Object.entries(CONFIG.highlightGroups)) {
				if (groupConfig.col) {
					params.set(`highlight.${groupName}.col`, groupConfig.col);
				}
				if (groupConfig.values && groupConfig.values.length > 0) {
					params.set(`highlight.${groupName}.values`, groupConfig.values.join(','));
				}
				if (groupConfig.color) {
					params.set(`highlight.${groupName}.color`, groupConfig.color);
				}
			}
		}
	
		return params;
	}
	
	/**
	 * Find differences between current config and loaded config
	 * Returns array of [path, value] tuples
	 * Uses epsilon comparison for floats
	 */
	function findConfigDifferences(current, base, prefix = '') {
		const differences = [];
		const EPSILON = 0.001;
	
		for (const key in current) {
			if (key === "data") {
				// Skip the data field to prevent huge URLs
				continue;
			}
			const currentPath = prefix ? `${prefix}.${key}` : key;
			const currentValue = current[key];
			const baseValue = base[key];
	
			if (Array.isArray(currentValue)) {
				// Special handling for arrays
				if (!Array.isArray(baseValue) || !arraysEqual(currentValue, baseValue)) {
					differences.push([currentPath, currentValue]);
				}
			} else if (typeof currentValue === 'object' && currentValue !== null) {
				if (typeof baseValue === 'object' && !Array.isArray(baseValue) && baseValue !== null) {
					differences.push(...findConfigDifferences(currentValue, baseValue, currentPath));
				} else {
					// Base doesn't have this object, include all of current
					differences.push([currentPath, JSON.stringify(currentValue)]);
				}
			} else {
				// Compare primitive values with epsilon for floats
				let valuesEqual = false;
	
				if (typeof currentValue === 'number' && typeof baseValue === 'number') {
					// Use epsilon comparison for floats
					valuesEqual = Math.abs(currentValue - baseValue) < EPSILON;
				} else {
					// Direct comparison for other types
					valuesEqual = currentValue === baseValue;
				}
	
				if (!valuesEqual) {
					differences.push([currentPath, currentValue]);
				}
			}
		}
	
		return differences;
	}
	
	/**
	 * Helper function to compare arrays
	 */
	function arraysEqual(arr1, arr2) {
		if (arr1.length !== arr2.length) return false;
		for (let i = 0; i < arr1.length; i++) {
			if (arr1[i] !== arr2[i]) return false;
		}
		return true;
	}
	
	/**
	 * Get the current configuration as a formatted JSON string
	 */
	function getConfigAsJSON() {
		return JSON.stringify(CONFIG, null, 2);
	}
	
	/**
	 * Open a new tab with the current configuration
	 */
	function exportConfigToNewTab() {
		const configText = getConfigAsJSON();
		const blob = new Blob([configText], { type: 'application/json' });
		const url = URL.createObjectURL(blob);
		const newWindow = window.open(url, '_blank');
	
		// Clean up the object URL after a delay
		setTimeout(() => {
			URL.revokeObjectURL(url);
		}, 1000);
	}
	
	
	/**
	 * Reset CONFIG to the loaded config.json state and clear URL parameters
	 */
	function resetConfigToLoaded() {
		if (!LOADED_CONFIG) {
			console.warn("No loaded config available, resetting to defaults");
			CONFIG = getDefaultConfig();
		} else {
			// Deep copy the loaded config back to CONFIG
			CONFIG = JSON.parse(JSON.stringify(LOADED_CONFIG));
		}
	
		// Clear URL parameters by navigating to clean URL
		const cleanURL = window.location.pathname;
		window.history.replaceState({}, '', cleanURL);
	
		// Clear the URL update timeout if it exists
		if (URL_UPDATE_TIMEOUT) {
			clearTimeout(URL_UPDATE_TIMEOUT);
			URL_UPDATE_TIMEOUT = null;
		}
	
		console.log("Config reset to loaded state and URL cleared");
	}
	</script>
	<!-- end 'config.js' -->
		<!-- begin 'notif.js' -->
	<script>
	/* notif.js - Standalone notification system */
	class NotificationManager {
	    constructor(options = {}) {
	        // Timeout settings
	        this.defaultTimeout = options.defaultTimeout || 4000;
	        this.successTimeout = options.successTimeout || 2000;
	        this.fadeTimeout = options.fadeTimeout || 300;
	
	        // Layout settings
	        this.topOffset = options.topOffset || 20;
	        this.spacing = options.spacing || 60;
	        this.slideOffset = options.slideOffset || -20;
	
	        this.notifications = new Map(); // Map of id -> notification data
	        this.nextId = 0;
	        this.container = null;
	        this.isReady = false;
	
	        // Initialize when DOM is ready
	        this._initWhenReady();
	    }
	
	    _initWhenReady() {
	        if (document.body) {
	            this._createContainer();
	            this.isReady = true;
	        } else if (document.readyState === 'loading') {
	            document.addEventListener('DOMContentLoaded', () => {
	                this._createContainer();
	                this.isReady = true;
	            });
	        } else {
	            // DOM is ready but body might not be parsed yet
	            setTimeout(() => this._initWhenReady(), 10);
	        }
	    }
	
	    _createContainer() {
	        if (this.container) return; // Already created
	
	        this.container = document.createElement('div');
	        this.container.className = 'notification-container';
	        document.body.appendChild(this.container);
	    }
	
	    _ensureReady() {
	        if (!this.isReady) {
	            console.warn('NotificationManager not ready yet, initializing synchronously');
	            this._createContainer();
	            this.isReady = true;
	        }
	    }
	
	    _createNotificationElement(id, type, message) {
	        this._ensureReady();
	
	        const element = document.createElement('div');
	        element.className = `notification-indicator visible ${type}`;
	        element.dataset.id = id;
	
	        if (type === 'spinner') {
	            element.innerHTML = `
	                <span class="notification-spinner"></span>
	                <span class="notification-text">${message}</span>
	            `;
	        } else if (type === 'pbar') {
	            element.innerHTML = `
	                <div class="notification-text">${message}</div>
	                <div class="notification-progress-container">
	                    <div class="notification-progress-bar" style="width: 0%"></div>
	                </div>
	            `;
	        } else {
	            element.innerHTML = `
	                <span class="notification-text">${message}</span>
	            `;
	        }
	
	        this.container.appendChild(element);
	        this._updatePositions();
	        return element;
	    }
	
	    _updatePositions() {
	        if (!this.container) return;
	
	        const notifications = Array.from(this.container.children);
	        notifications.forEach((el, index) => {
	            el.style.top = `${this.topOffset + index * this.spacing}px`;
	        });
	    }
	
	    _removeNotification(id) {
	        const notifData = this.notifications.get(id);
	        if (!notifData) return;
	
	        // Clear timeout if exists
	        if (notifData.timeout) {
	            clearTimeout(notifData.timeout);
	        }
	
	        // Remove element with fade animation
	        notifData.element.style.opacity = '0';
	        notifData.element.style.transform = `translateX(-50%) translateY(${this.slideOffset}px)`;
	
	        setTimeout(() => {
	            if (notifData.element.parentNode) {
	                notifData.element.parentNode.removeChild(notifData.element);
	            }
	            this.notifications.delete(id);
	            this._updatePositions();
	        }, this.fadeTimeout);
	    }
	
	    /**
	     * Show a regular notification message
	     * @param {string} message - Message to display
	     * @param {number} timeout - Auto-hide timeout in ms (default from constructor)
	     */
	    show(message, timeout = null) {
	        console.log(message);
	
	        const id = this.nextId++;
	        const element = this._createNotificationElement(id, 'show', message);
	
	        const hideTimeout = timeout || this.defaultTimeout;
	        const timeoutId = setTimeout(() => {
	            this._removeNotification(id);
	        }, hideTimeout);
	
	        this.notifications.set(id, {
	            element,
	            type: 'show',
	            timeout: timeoutId
	        });
	    }
	
	    /**
	     * Show a persistent spinner with message
	     * @param {string} message - Loading message to display
	     * @returns {object} Spinner control object with .complete() method
	     */
	    spinner(message) {
	        console.log(message);
	
	        const id = this.nextId++;
	        const element = this._createNotificationElement(id, 'spinner', message);
	
	        this.notifications.set(id, {
	            element,
	            type: 'spinner',
	            timeout: null
	        });
	
	        return {
	            complete: () => {
	                this._removeNotification(id);
	            }
	        };
	    }
	
	    /**
	     * Show a persistent progress bar with message
	     * @param {string} message - Loading message to display
	     * @returns {object} Progress bar control object with .progress(value) method
	     */
	    pbar(message) {
	        console.log(message);
	
	        const id = this.nextId++;
	        const element = this._createNotificationElement(id, 'pbar', message);
	
	        this.notifications.set(id, {
	            element,
	            type: 'pbar',
	            timeout: null
	        });
	
	        return {
	            progress: (value) => {
	                const progressBar = element.querySelector('.notification-progress-bar');
	                if (progressBar) {
	                    const percentage = Math.max(0, Math.min(100, value * 100));
	                    progressBar.style.width = `${percentage}%`;
	                }
	            },
	            complete: () => {
	                this._removeNotification(id);
	            }
	        };
	    }
	
	    /**
	     * Show success message
	     * @param {string} message - Success message
	     * @param {number} timeout - Auto-hide timeout in ms (default from constructor)
	     */
	    success(message, timeout = null) {
	        console.log(message);
	
	        const id = this.nextId++;
	        const element = this._createNotificationElement(id, 'success', message);
	
	        const hideTimeout = timeout || this.successTimeout;
	        const timeoutId = setTimeout(() => {
	            this._removeNotification(id);
	        }, hideTimeout);
	
	        this.notifications.set(id, {
	            element,
	            type: 'success',
	            timeout: timeoutId
	        });
	    }
	
	    /**
	     * Show error message
	     * @param {string} message - Error message
	     * @param {Error} err - Error object to log
	     * @param {number} timeout - Auto-hide timeout in ms (default from constructor)
	     */
	    error(message, err = null, timeout = null) {
	        if (err) {
	            console.error(err);
	        } else {
	            console.error(message);
	        }
	
	        const id = this.nextId++;
	        const element = this._createNotificationElement(id, 'error', message);
	
	        const hideTimeout = timeout || this.defaultTimeout;
	        const timeoutId = setTimeout(() => {
	            this._removeNotification(id);
	        }, hideTimeout);
	
	        this.notifications.set(id, {
	            element,
	            type: 'error',
	            timeout: timeoutId
	        });
	    }
	
	    /**
	     * Hide all notifications
	     */
	    clear() {
	        for (const [id] of this.notifications) {
	            this._removeNotification(id);
	        }
	    }
	}
	
	// Initialize global instance when DOM is ready
	let NOTIF;
	
	// Initialize immediately if DOM is already ready, otherwise wait
	if (document.readyState === 'loading') {
	    document.addEventListener('DOMContentLoaded', () => {
	        NOTIF = new NotificationManager();
	    });
	} else {
	    // DOM already loaded
	    NOTIF = new NotificationManager();
	}
	</script>
	<!-- end 'notif.js' -->
		<!-- begin 'ColorUtil.js' -->
	<script>
	function hslToHex(h, s, l) {
		s /= 100; l /= 100;
		const c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c / 2;
		let r, g, b;
		if (h < 60) [r, g, b] = [c, x, 0];
		else if (h < 120) [r, g, b] = [x, c, 0];
		else if (h < 180) [r, g, b] = [0, c, x];
		else if (h < 240) [r, g, b] = [0, x, c];
		else if (h < 300) [r, g, b] = [x, 0, c];
		else[r, g, b] = [c, 0, x];
		const toHex = v => { const h = Math.round((v + m) * 255).toString(16); return h.length === 1 ? '0' + h : h };
		return '#' + toHex(r) + toHex(g) + toHex(b);
	}
	
	function generateDistinctColors(n) {
		const out = [];
		for (let i = 0; i < n; i++) {
			const h = Math.floor(Math.random() * 360),
				s = Math.floor(50 + Math.random() * 50),
				l = Math.floor(40 + Math.random() * 20);
			out.push(hslToHex(h, s, l));
		}
		return out;
	}
	
	</script>
	<!-- end 'ColorUtil.js' -->
		<!-- begin 'DataFrame.js' -->
	<script>
	class DataFrame {
		/**
		 * Creates a DataFrame from a list of row objects
		 * 
		 * @param {Array<Object>} data - Array of row objects
		 * @param {Array<string>} [columns] - Optional column names (will be inferred from data if not provided)
		 */
		constructor(data = [], columns = null) {
			this.data = data;
	
			// Infer columns from data if not provided
			if (!columns && data.length > 0) {
				this.columns = Object.keys(data[0]);
			} else {
				this.columns = columns || [];
			}
		}
	
		/**
		 * Returns the values for a specific column
		 * 
		 * @param {string} name - Column name
		 * @returns {Array} - Values in the column
		 */
		col(name) {
			if (!this.columns.includes(name)) {
				throw new Error(`Column '${name}' not found in columns: ${this.columns.join(', ')}`);
			}
	
			return this.data.map(row => row[name]);
		}
	
		/**
		 * Returns the values for a specific cell
		 * @param {row_idx} row_idx - Row index
		 * @param {col_name} col_name - Column name
		 * @returns {any} - Value in the cell
		 * @throws {Error} - If row index or column name is invalid
		 */
		get(row_idx, col_name) {
			if (row_idx < 0 || row_idx >= this.data.length) {
				throw new Error(`Row index ${row_idx} out of bounds (0 to ${this.data.length - 1})`);
			}
	
			if (!this.columns.includes(col_name)) {
				throw new Error(`Column '${col_name}' not found in columns: ${this.columns.join(', ')}`);
			}
	
			return this.data[row_idx][col_name];
		}
	
		/**
		 * Returns a specific row as an object
		 * 
		 * @param {number} rowIdx - Row index
		 * @returns {Object} - Row as an object
		 */
		row(rowIdx) {
			if (rowIdx < 0 || rowIdx >= this.data.length) {
				throw new Error(`Row index ${rowIdx} out of bounds (0 to ${this.data.length - 1})`);
			}
	
			return this.data[rowIdx];
		}
	
		/**
		 * Returns unique values in a specific column
		 * @param {string} name - Column name
		 * @returns {Set} - Unique values in the column
		 */
		col_unique(name) {
			return new Set(this.col(name));
		}
	
		/**
		 * Parses a CSV string into a DataFrame.
		 *
		 * Note: This is a simple CSV parser that splits on commas and newlines.
		 * It does NOT support:
		 * - Commas within fields (even if quoted)
		 * - Newlines within fields
		 * - Escaped quotes
		 *
		 * For complex data, use JSONL format instead (see from_jsonl).
		 *
		 * @param {string} text - CSV text content
		 * @returns {DataFrame} - New DataFrame instance
		 */
		static from_csv(text) {
			// Split text into lines and filter out empty lines
			const lines = text.split('\n').filter(line => line.trim().length > 0);
	
			if (lines.length === 0) {
				return new DataFrame();
			}
	
			// First line is the header
			const header = lines[0].split(',').map(col => col.trim());
	
			// Parse each line into a row object
			const data = [];
			for (let i = 1; i < lines.length; i++) {
				const values = lines[i].split(',').map(val => val.trim());
	
				// Create row object mapping column names to values
				const row = {};
				for (let j = 0; j < header.length; j++) {
					// Try to convert to number if possible
					const value = values[j];
					if (value === undefined) continue;
	
					// Handle quoted strings
					if (value.startsWith('"') && value.endsWith('"')) {
						row[header[j]] = value.slice(1, -1);
					}
					// Handle null values
					else if (value === '' || value.toLowerCase() === 'null') {
						row[header[j]] = null;
					}
					// Try converting to number
					else if (!isNaN(value)) {
						row[header[j]] = Number(value);
					}
					// Otherwise keep as string
					else {
						row[header[j]] = value;
					}
				}
	
				data.push(row);
			}
	
			return new DataFrame(data, header);
		}
	
		/**
		 * Converts DataFrame to CSV string
		 * 
		 * @returns {string} - CSV representation of the DataFrame
		 */
		to_csv() {
			if (this.data.length === 0) {
				return this.columns.join(',');
			}
	
			// Start with the header
			const lines = [this.columns.join(',')];
	
			// Add each row
			for (const row of this.data) {
				const values = this.columns.map(col => {
					const val = row[col];
	
					if (val === null || val === undefined) {
						return '';
					} else if (typeof val === 'string' && (val.includes(',') || val.includes('"'))) {
						// Escape quotes and wrap in quotes
						return `"${val.replace(/"/g, '""')}"`;
					} else {
						return String(val);
					}
				});
	
				lines.push(values.join(','));
			}
	
			return lines.join('\n');
		}
	
		/**
		 * Parses a JSONL string into a DataFrame
		 * 
		 * @param {string} text - JSONL text content
		 * @returns {DataFrame} - New DataFrame instance
		 */
		static from_jsonl(text) {
			// Parse each line as JSON with error handling
			const lines = text.trim().split('\n');
			const data = [];
			const errors = [];
	
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i].trim();
				if (!line) continue; // Skip empty lines
	
				try {
					data.push(JSON.parse(line));
				} catch (e) {
					errors.push({ line: i + 1, message: e.message });
					console.warn(`Skipping malformed JSON at line ${i + 1}: ${e.message}`);
				}
			}
	
			// Show persistent error toast if there were parsing errors
			if (errors.length > 0) {
				const errorMsg = `${errors.length}/${lines.length} lines had malformed JSON (check console for line numbers)`;
				if (typeof NOTIF !== 'undefined') {
					NOTIF.error(errorMsg, null, 60000); // Persistent for 60 seconds
				}
			}
	
			// Extract all unique column names from all rows
			const allColumns = new Set();
			for (const row of data) {
				Object.keys(row).forEach(key => allColumns.add(key));
			}
	
			return new DataFrame(data, Array.from(allColumns));
		}
	
		/**
		 * Converts DataFrame to JSONL string
		 * 
		 * @returns {string} - JSONL representation of the DataFrame
		 */
		to_jsonl() {
			return this.data.map(row => JSON.stringify(row)).join('\n');
		}
	
		/**
		 * Returns the number of rows in the DataFrame
		 * 
		 * @returns {number} - Number of rows
		 */
		get length() {
			return this.data.length;
		}
	
		/**
		 * Returns a string representation of the DataFrame
		 * 
		 * @returns {string} - String representation
		 */
		toString() {
			if (this.data.length === 0) {
				return 'Empty DataFrame';
			}
	
			return `DataFrame with ${this.data.length} rows and ${this.columns.length} columns: ${this.columns.join(', ')}`;
		}
	}
	
	</script>
	<!-- end 'DataFrame.js' -->
		<!-- begin 'DataModel.js' -->
	<script>
	class DataModel {
		constructor(df, numericCols) {
			this.df = df;
			this.numericCols = numericCols;                // ordered ["pc.0", ]
			this.rowCount = df.data.length;
			this._pcaFlat = this._buildFlatArray();        // Float32Array row-major
		}
	
		_buildFlatArray() {
			const out = new Float32Array(this.rowCount * this.numericCols.length);
			for (let i = 0; i < this.rowCount; i++) {
				const row = this.df.data[i];
				for (let j = 0; j < this.numericCols.length; j++) {
					out[i * this.numericCols.length + j] = row[this.numericCols[j]];
				}
			}
			return out;
		}
	
		/** fast accessor */
		getCoord(rowIdx, axisIdx) {
			return this._pcaFlat[rowIdx * this.numericCols.length + axisIdx];
		}
	
		row(idx) { return this.df.data[idx]; }
	
		static async load(filename, numericalPrefix) {
			const spinner = NOTIF.spinner('Processing data...');
	
			try {
				let df;
				let pbar;
	
				// Check if dataFile is null - use embedded data
				if (filename === null || filename === undefined) {
					if (!CONFIG.data || !Array.isArray(CONFIG.data)) {
						const errorMsg = 'No dataFile specified and no embedded data found in CONFIG.data';
						spinner.complete();
						NOTIF.error(errorMsg, new Error(errorMsg));
						throw new Error(errorMsg);
					}
	
					// Use embedded data directly
					spinner.complete();
					pbar = NOTIF.pbar('Processing embedded data...');
					pbar.progress(0.2);
	
					// Extract all unique column names from all rows
					const allColumns = new Set();
					for (const row of CONFIG.data) {
						Object.keys(row).forEach(key => allColumns.add(key));
					}
	
					pbar.progress(0.6);
					df = new DataFrame(CONFIG.data, Array.from(allColumns));
					pbar.progress(0.9);
	
				} else {
					// Original file loading logic
					spinner.complete();
					const downloadSpinner = NOTIF.spinner('Downloading data...');
	
					let resp;
					try {
						resp = await fetch(filename);
					} catch (networkError) {
						downloadSpinner.complete();
						const errorMsg = `Network error loading data: ${networkError.message}`;
						NOTIF.error(errorMsg, networkError, 30000);
						throw networkError;
					}
	
					if (!resp.ok) {
						const errorMsg = `Failed to load data: ${resp.status} ${resp.statusText}`;
						downloadSpinner.complete();
						NOTIF.error(errorMsg, new Error(errorMsg), 30000);
						throw new Error(errorMsg);
					}
	
					downloadSpinner.complete();
					pbar = NOTIF.pbar('Processing data...');
	
					pbar.progress(0.1);
					const text = await resp.text();
	
					pbar.progress(0.3);
					df = DataFrame.from_jsonl(text);
					pbar.progress(0.6);
				}
	
				const numeric = df.columns
					.filter(c => c.startsWith(numericalPrefix))
					.sort((a, b) => {
						// Extract the part after the prefix
						const aSuffix = a.substring(numericalPrefix.length);
						const bSuffix = b.substring(numericalPrefix.length);
	
						// Check if both suffixes are integers
						const aNum = parseInt(aSuffix, 10);
						const bNum = parseInt(bSuffix, 10);
	
						// If both are valid integers, sort numerically
						if (!isNaN(aNum) && !isNaN(bNum) &&
							aNum.toString() === aSuffix && bNum.toString() === bSuffix) {
							return aNum - bNum;
						}
	
						// Otherwise, sort lexicographically
						return a.localeCompare(b);
					});
	
				const result = new DataModel(df, numeric);
	
				pbar.progress(1.0);
				pbar.complete();
				NOTIF.success(`Loaded ${df.data.length} data points with ${numeric.length} dimensions`);
	
				return result;
			} catch (error) {
				spinner.complete();
				if (pbar) pbar.complete();
				NOTIF.error('Failed to load data', error, 99999999999);
				console.error("DataModel load error:", error);
				throw error;
			}
		}
	}
	</script>
	<!-- end 'DataModel.js' -->
		<!-- begin 'SelectionManager.js' -->
	<script>
	/* SelectionManager.js  -- optimized version using CONFIG */
	class SelectionManager {
		constructor(model, state) {
			this.model = model;
			this.state = state;
			this.palette = generateDistinctColors(CONFIG.colors.paletteSize);
	
			// Cache for expensive computations
			this._colorCache = new Map();
			this._numericRangeCache = new Map();
			this._isNumericColumnCache = new Map();
	
			// Cache for highlight group colors
			this._highlightGroupColors = new Map();
			this._initHighlightGroupColors();
		}
	
		/** Initialize colors for highlight groups */
		_initHighlightGroupColors() {
			this._highlightGroupColors.clear();
			if (CONFIG.highlightGroups) {
				for (const [groupName, groupConfig] of Object.entries(CONFIG.highlightGroups)) {
					if (groupConfig.color) {
						// Use specified color
						this._highlightGroupColors.set(groupName, new THREE.Color(groupConfig.color));
					} else {
						// Generate a random color
						const randomHex = generateDistinctColors(1)[0];
						this._highlightGroupColors.set(groupName, new THREE.Color(randomHex));
					}
				}
			}
		}
	
		/** Check if a row matches any highlight group, returns first match */
		_getHighlightGroup(row) {
			if (!CONFIG.highlightGroups) return null;
	
			// Iterate in object key order (first defined = first priority)
			for (const [groupName, groupConfig] of Object.entries(CONFIG.highlightGroups)) {
				const columnValue = row[groupConfig.col];
				if (groupConfig.values && groupConfig.values.includes(String(columnValue))) {
					return groupName;
				}
			}
			return null;
		}
	
		/** colour & selection attributes for a given row id */
		attrs(rowId) {
			const row = this.model.row(rowId);
	
			// Check highlight groups FIRST (supersedes selection)
			const highlightGroup = this._getHighlightGroup(row);
			if (highlightGroup) {
				const highlightColor = this._highlightGroupColors.get(highlightGroup);
				return {
					r: highlightColor.r,
					g: highlightColor.g,
					b: highlightColor.b,
					size: this.state.selSize,
					opacity: this.state.selOp
				};
			}
	
			// Check if this point should be treated as selected
			const selectValue = row[this.state.selectBy];
			const isExplicitlySelected = this.state.selection.has(selectValue);
			const isValidValue = selectValue !== null && selectValue !== 'null' && selectValue !== 'unknown';
	
			// If no explicit selection, treat all valid points as selected
			// BUT if highlightGroups are defined, non-highlighted points should be unselected
			const hasHighlightGroups = CONFIG.highlightGroups && Object.keys(CONFIG.highlightGroups).length > 0;
			const treatAsSelected = isExplicitlySelected || (this.state.selection.size === 0 && isValidValue && !hasHighlightGroups);
	
			// Get base color from colorBy column (with caching)
			const colorValue = row[this.state.colorBy];
			const baseColor = this._getColorCached(colorValue);
	
			// Apply selection highlighting
			if (treatAsSelected) {
				return {
					r: baseColor.r,
					g: baseColor.g,
					b: baseColor.b,
					size: this.state.selSize,
					opacity: this.state.selOp
				};
			} else {
				// Non-selected styling
				const nonSelColor = new THREE.Color(this.state.nonSelColor);
				return {
					r: nonSelColor.r,
					g: nonSelColor.g,
					b: nonSelColor.b,
					size: this.state.nonSelSize,
					opacity: this.state.nonSelOp
				};
			}
		}
	
		_getColorCached(value) {
			const cacheKey = `${this.state.colorBy}:${value}`;
	
			if (!this._colorCache.has(cacheKey)) {
				let color;
				if (this._isNumericColumnCached(this.state.colorBy)) {
					color = this._getViridisColor(value, this.state.colorBy);
				} else {
					color = this._getCategoricalColor(value);
				}
				this._colorCache.set(cacheKey, color);
			}
	
			return this._colorCache.get(cacheKey);
		}
	
		_isNumericColumnCached(column) {
			if (!this._isNumericColumnCache.has(column)) {
				this._isNumericColumnCache.set(column, this.state.isNumericColumn(column));
			}
			return this._isNumericColumnCache.get(column);
		}
	
		_getViridisColor(value, column) {
			if (value === null || value === undefined || isNaN(value)) {
				return new THREE.Color(CONFIG.colors.nullValueColor);
			}
	
			// Get cached min/max for the column
			if (!this._numericRangeCache.has(column)) {
				const values = this.model.df.col(column).filter(v => typeof v === 'number' && !isNaN(v));
				if (values.length === 0) {
					NOTIF.show(`Column "${column}" has no numeric values`, 4000);
					this._numericRangeCache.set(column, { min: 0, max: 0 });
				} else {
					const min = values.reduce((a, b) => Math.min(a, b), Infinity);
					const max = values.reduce((a, b) => Math.max(a, b), -Infinity);
					this._numericRangeCache.set(column, { min, max });
				}
			}
	
			const { min, max } = this._numericRangeCache.get(column);
	
			// Normalize to 0-1
			const t = max > min ? (value - min) / (max - min) : 0;
	
			// Viridis colormap approximation using CONFIG coefficients
			return this._viridis(t);
		}
	
		_getCategoricalColor(value) {
			if (value === null || value === 'null' || value === 'unknown') {
				return new THREE.Color(CONFIG.colors.nullValueColor);
			}
	
			// Use a simple hash for categorical values to avoid expensive sorting
			const hash = typeof value === 'string'
				? [...value].reduce((s, c) => s + c.charCodeAt(0), 0)
				: (value | 0);
	
			return new THREE.Color(this.palette[hash % this.palette.length]);
		}
	
		_viridis(t) {
			// Viridis colormap approximation using CONFIG coefficients
			t = Math.max(0, Math.min(1, t));
	
			const { r: rCoeff, g: gCoeff, b: bCoeff } = CONFIG.colors.viridisColors;
	
			const r = rCoeff[0] + t * (rCoeff[1] + t * (rCoeff[2] + t * (rCoeff[3] + t * (rCoeff[4] + t * rCoeff[5]))));
			const g = gCoeff[0] + t * (gCoeff[1] + t * (gCoeff[2] + t * (gCoeff[3] + t * (gCoeff[4] + t * gCoeff[5]))));
			const b = bCoeff[0] + t * (bCoeff[1] + t * (bCoeff[2] + t * (bCoeff[3] + t * (bCoeff[4] + t * bCoeff[5]))));
	
			return new THREE.Color(r, g, b);
		}
	
		randomizeColors() {
			this.palette = generateDistinctColors(CONFIG.colors.paletteSize);
			// Clear color cache when palette changes
			this._colorCache.clear();
	
			// Also randomize highlight group colors (unless explicitly specified)
			if (CONFIG.highlightGroups) {
				for (const [groupName, groupConfig] of Object.entries(CONFIG.highlightGroups)) {
					if (!groupConfig.color) {
						// Only randomize auto-generated colors, not user-specified ones
						const randomHex = generateDistinctColors(1)[0];
						this._highlightGroupColors.set(groupName, new THREE.Color(randomHex));
					}
				}
			}
		}
	
		// Clear caches when column changes
		clearCaches() {
			this._colorCache.clear();
			this._numericRangeCache.clear();
			this._isNumericColumnCache.clear();
		}
	}
	</script>
	<!-- end 'SelectionManager.js' -->
		<!-- begin 'VisState.js' -->
	<script>
	/* VisState.js  -- replaces previous version with URL sync */
	class VisState extends EventTarget {
		constructor(model) {
			super();
			this.model = model;
	
			/* view / meta options - use CONFIG defaults */
			this.axis = { ...CONFIG.axes };
	
			/* run-time configurable keys */
			this.colorBy = CONFIG.defaultColorColumn;
			this.selectBy = CONFIG.defaultSelectionColumn;
	
			/* appearance - use CONFIG defaults */
			this.nonSelSize = CONFIG.nonSelectedPoints.size;
			this.selSize = CONFIG.selectedPoints.size;
			this.nonSelOp = CONFIG.nonSelectedPoints.opacity;
			this.selOp = CONFIG.selectedPoints.opacity;
			this.nonSelColor = CONFIG.nonSelectedPoints.color;
			this.bgColor = CONFIG.rendering.clearColor;
	
			/* store *values* (categories) now, not row indices */
			this.selection = new Set();
	
			// Initialize selection from CONFIG if specified
			// Handle both array and single value cases from URL parsing
			if (CONFIG.selectedValues) {
				if (Array.isArray(CONFIG.selectedValues)) {
					CONFIG.selectedValues.forEach(value => this.selection.add(value));
				} else if (typeof CONFIG.selectedValues === 'string') {
					// Single value from URL (not comma-separated)
					this.selection.add(CONFIG.selectedValues);
					// Update CONFIG to be consistent array format
					CONFIG.selectedValues = [CONFIG.selectedValues];
				}
			}
		}
	
		isNumericColumn(column) {
			if (!this.model.df.columns.includes(column)) return false;
	
			const values = this.model.df.col(column);
			// Check if most values are numbers
			const numericCount = values.filter(v => typeof v === 'number' && !isNaN(v)).length;
			return numericCount > values.length * 0.8; // 80% threshold
		}
	
		/* ---------- helpers ---------- */
		setAxis(dim, val) {
			this.axis[dim] = val;
			// Update CONFIG to keep it in sync
			CONFIG.axes[dim] = val;
			this._syncToURL();
			this._fire('axis');
		}
	
		setColorBy(col) {
			this.colorBy = col;
			CONFIG.defaultColorColumn = col;
			this._syncToURL();
			this._fire('vis');
		}
	
		setSelectBy(col) {
			this.selectBy = col;
			CONFIG.defaultSelectionColumn = col;
			this.clearSel();
			this._syncToURL();
			this._fire('vis');
		}
	
		setVisParam(k, v) {
			this[k] = v;
	
			// Update CONFIG to keep it in sync
			switch (k) {
				case 'selSize':
					CONFIG.selectedPoints.size = v;
					break;
				case 'selOp':
					CONFIG.selectedPoints.opacity = v;
					break;
				case 'nonSelSize':
					CONFIG.nonSelectedPoints.size = v;
					break;
				case 'nonSelOp':
					CONFIG.nonSelectedPoints.opacity = v;
					break;
				case 'nonSelColor':
					CONFIG.nonSelectedPoints.color = v;
					break;
				case 'bgColor':
					CONFIG.rendering.clearColor = v;
					break;
			}
	
			this._syncToURL();
			this._fire('vis');
		}
	
		/** toggle category value */
		toggleValue(v) {
			if (v == null) return;
			this.selection.has(v) ? this.selection.delete(v)
				: this.selection.add(v);
	
			// Update CONFIG with current selection
			CONFIG.selectedValues = Array.from(this.selection);
			this._syncToURL();
			this._fire('selection');
		}
	
		clearSel() {
			this.selection.clear();
			CONFIG.selectedValues = [];
			this._syncToURL();
			this._fire('selection');
		}
	
		/**
		 * Sync current state to URL parameters
		 */
		_syncToURL() {
			updateURL();
		}
	
		_fire(type) { this.dispatchEvent(new Event(type)); }
	}
	</script>
	<!-- end 'VisState.js' -->
		<!-- begin 'ui.js' -->
	<script>
	/* ui.js - Updated to use CONFIG values and add export button */
	class UIManager {
	    constructor(pointCloud) {
	        this.pointCloud = pointCloud;
	
	        /* panel metadata - now uses CONFIG -------------------------------- */
	        this.uiConfig = {
	            help: { key: 'KeyH', elementId: 'helpMenu', shortcutText: 'h  help', visible: CONFIG.panels.help },
	            menu: { key: 'KeyM', elementId: 'controlsMenu', shortcutText: 'm  menu', visible: CONFIG.panels.menu },
	            info: { key: 'KeyI', elementId: 'infoMenu', shortcutText: 'i  info', visible: CONFIG.panels.info },
	            legend: { key: 'KeyL', elementId: 'legendMenu', shortcutText: 'l  legend', visible: CONFIG.panels.legend },
	            navbar: { key: 'KeyN', elementId: 'navbar', shortcutText: 'n  navball', visible: CONFIG.panels.navbar },
	            stats: { key: 'KeyJ', elementId: 'statsMenu', shortcutText: 'j  stats', visible: CONFIG.panels.stats }
	        };
	
	        /* categorical columns for c / v cycling ------------------------ */
	        this.cats = this.pointCloud.model.df.columns
	            .filter(c => !c.startsWith(CONFIG.numericalPrefix));
	        this.colorIdx = Math.max(0, this.cats.indexOf(this.pointCloud.state.colorBy));
	        this.selectIdx = Math.max(0, this.cats.indexOf(this.pointCloud.state.selectBy));
	
	        /* FPS counters -------------------------------------------------- */
	        this.frameCount = 0;
	        this.lastTime = performance.now();
	        this.fps = 60;
	
	        /* Performance safeguard - now uses CONFIG ---------------------- */
	        this.performanceCheckInterval = CONFIG.performance.performanceCheckInterval;
	        this.lastPerformanceCheck = performance.now();
	        this.fpsThreshold = CONFIG.performance.fpsThreshold;
	        this.performanceWarningShown = false;
	
	        /* build static UI */
	        this._init();
	    }
	
	    /* ========================================================= */
	    _init() {
	        this._buildShortcutsLegend();
	        this._setupControlSliders();
	        this._bindKeys();
	        this._setupNavball();
	
	        /* hover tooltip */
	        this.hoverPanel = document.createElement('div');
	        this.hoverPanel.className = 'hover-panel';
	        document.body.appendChild(this.hoverPanel);
	
	        /* attach onceonly grid listeners for selected values & legend */
	        this._attachGridListeners();
	
	
	        // Apply initial panel visibility from CONFIG
	        this._applyInitialPanelVisibility();
	
	        // for changes in columns, color, or selection
	        this._updateLegendDisplay()
	        this._updateSelectedValuesDisplay();
	        this.pointCloud.state.addEventListener('vis', () => {
	            this._updateLegendDisplay();
	            this._updateSelectedValuesDisplay();
	        });
	        this.pointCloud.state.addEventListener('selection', () => {
	            this._updateLegendDisplay();
	            this._updateSelectedValuesDisplay();
	        });
	    }
	
	    _applyInitialPanelVisibility() {
	        for (const [name, cfg] of Object.entries(this.uiConfig)) {
	            document.getElementById(cfg.elementId).style.display = cfg.visible ? 'block' : 'none';
	        }
	    }
	
	    /* ... (keeping _attachGridListeners unchanged) ... */
	    _attachGridListeners() {
	        /* Selected-values grid (the info panel) */
	        const selGrid = document.getElementById('selectedValuesGrid');
	        if (selGrid) {
	            selGrid.addEventListener('click', (e) => {
	                console.log('[UIManager] selected-values grid clicked');
	                console.log(e)
	                // We look for a .remove-btn in the event's ancestry
	                const btn = e.target.closest('.remove-btn');
	                if (!btn) return;
	                e.stopPropagation();
	
	                const valueToRemove = btn.getAttribute('data-value');
	                console.log('[UIManager] remove-btn clicked ->', valueToRemove);
	                this.pointCloud.state.toggleValue(valueToRemove);
	            });
	        }
	
	        /* Legend grid */
	        const legendGrid = document.getElementById('legendGrid');
	        if (legendGrid) {
	            legendGrid.addEventListener('click', (e) => {
	                // We look for a .legend-item-clickable
	                const item = e.target.closest('.legend-item-clickable');
	                if (!item) return;
	                e.stopPropagation();
	
	                const value = item.getAttribute('data-value');
	                this.pointCloud.state.toggleValue(value);
	            });
	        }
	    }
	
	    _setupNavball() {
	        this.navball = new Navball('navball-container', CONFIG.navball.size);
	        // Apply initial visibility from CONFIG
	        document.getElementById('navbar').style.display = CONFIG.panels.navbar ? 'block' : 'none';
	        document.getElementById('legendMenu').style.display = CONFIG.panels.legend ? 'block' : 'none';
	    }
	
	    /* ---------- shortcuts legend (top-right) - using CONFIG ---------- */
	    _buildShortcutsLegend() {
	        const sc = document.getElementById('shortcuts');
	        sc.innerHTML = '<div>wasd  move</div><div>mouse + Q/E  roll</div>';
	
	        Object.values(this.uiConfig).forEach(cfg => {
	            const d = document.createElement('div');
	            d.className = 'shortcut-link';
	            d.dataset.action = cfg.elementId;
	            d.innerHTML = `${cfg.shortcutText} <span class="status-indicator ${cfg.visible ? 'status-enabled' : 'status-disabled'}">(${cfg.visible ? 'enabled' : 'disabled'})</span>`;
	            sc.appendChild(d);
	        });
	
	        // Add hover, click-select, and right-click shortcuts with status indicators from CONFIG
	        sc.insertAdjacentHTML('beforeend', `
	        <div class="shortcut-link" data-action="hover-toggle">k  hover UI <span class="status-indicator ${CONFIG.interaction.hoverActive ? 'status-enabled' : 'status-disabled'}" id="hover-status">(${CONFIG.interaction.hoverActive ? 'enabled' : 'disabled'})</span></div>
	        <div class="shortcut-link" data-action="click-select-toggle">b  click-select <span class="status-indicator ${CONFIG.interaction.selectOnClick ? 'status-enabled' : 'status-disabled'}" id="click-select-status">(${CONFIG.interaction.selectOnClick ? 'enabled' : 'disabled'})</span></div>
	        <div class="shortcut-link" data-action="right-click-toggle">o  right-click <span class="status-indicator ${CONFIG.interaction.rightClickActive ? 'status-enabled' : 'status-disabled'}" id="right-click-status">(${CONFIG.interaction.rightClickActive ? 'enabled' : 'disabled'})</span></div>
	        <div class="shortcut-link" data-action="middle-click-toggle">p  middle-click <span class="status-indicator ${CONFIG.middleClick.enabled ? 'status-enabled' : 'status-disabled'}" id="middle-click-status">(${CONFIG.middleClick.enabled ? 'enabled' : 'disabled'})</span></div>`);
	
	        sc.addEventListener('click', e => {
	            const target = e.target.closest('[data-action]');
	            if (!target) return;
	
	            const action = target.dataset.action;
	
	            if (action === 'hover-toggle') {
	                CONFIG.interaction.hoverActive = !CONFIG.interaction.hoverActive;
	                this.pointCloud.hoverActive = CONFIG.interaction.hoverActive;
	                this._updateStatusIndicator('hover-status', CONFIG.interaction.hoverActive);
	                if (!CONFIG.interaction.hoverActive) this.hoverPanel.style.display = 'none';
	                updateURL(); // Sync to URL
	            } else if (action === 'click-select-toggle') {
	                CONFIG.interaction.selectOnClick = !CONFIG.interaction.selectOnClick;
	                this.pointCloud.selectOnClick = CONFIG.interaction.selectOnClick;
	                this._updateStatusIndicator('click-select-status', CONFIG.interaction.selectOnClick);
	                updateURL(); // Sync to URL
	            } else if (action === 'right-click-toggle') {
	                CONFIG.interaction.rightClickActive = !CONFIG.interaction.rightClickActive;
	                this.pointCloud.rightClickActive = CONFIG.interaction.rightClickActive;
	                this._updateStatusIndicator('right-click-status', CONFIG.interaction.rightClickActive);
	                updateURL(); // Sync to URL
	            } else if (action === 'middle-click-toggle') {
	                CONFIG.middleClick.enabled = !CONFIG.middleClick.enabled;
	                this._updateStatusIndicator('middle-click-status', CONFIG.middleClick.enabled);
	                updateURL(); // Sync to URL
	            } else {
	                const entry = Object.entries(this.uiConfig)
	                    .find(([, cfg]) => cfg.elementId === action);
	                if (entry) {
	                    this._togglePanel(entry[0]);
	                    this._updatePanelStatusIndicator(target, this.uiConfig[entry[0]].visible);
	                }
	            }
	        });
	    }
	
	    /* ---------- sliders for size / opacity / speed - using CONFIG ---------- */
	    _setupControlSliders() {
	        // Point size controls - using CONFIG bounds
	        const pointSizeSlider = document.getElementById('pointSize');
	        const pointSizeValue = document.getElementById('pointSizeValue');
	        const nonSelPointSizeSlider = document.getElementById('nonSelPointSize');
	        const nonSelPointSizeValue = document.getElementById('nonSelPointSizeValue');
	
	        // Opacity controls - using CONFIG bounds
	        const opacitySlider = document.getElementById('opacity');
	        const opacityValue = document.getElementById('opacityValue');
	        const nonSelOpacitySlider = document.getElementById('nonSelOpacity');
	        const nonSelOpacityValue = document.getElementById('nonSelOpacityValue');
	
	        // Speed control - using CONFIG bounds
	        const speedSlider = document.getElementById('speed');
	        const speedValue = document.getElementById('speedValue');
	
	        // Color controls
	        const nonSelColorPicker = document.getElementById('nonSelColor');
	        const bgColorPicker = document.getElementById('bgColor');
	        const randomizeColorsBtn = document.getElementById('randomizeColors');
	
	        // Set up slider attributes from CONFIG
	        if (pointSizeSlider) {
	            pointSizeSlider.min = CONFIG.selectedPoints.sizeMin;
	            pointSizeSlider.max = CONFIG.selectedPoints.sizeMax;
	            pointSizeSlider.step = CONFIG.selectedPoints.sizeStep;
	            pointSizeSlider.value = CONFIG.selectedPoints.size;
	            if (pointSizeValue) pointSizeValue.textContent = CONFIG.selectedPoints.size;
	        }
	
	        if (nonSelPointSizeSlider) {
	            nonSelPointSizeSlider.min = CONFIG.nonSelectedPoints.sizeMin;
	            nonSelPointSizeSlider.max = CONFIG.nonSelectedPoints.sizeMax;
	            nonSelPointSizeSlider.step = CONFIG.nonSelectedPoints.sizeStep;
	            nonSelPointSizeSlider.value = CONFIG.nonSelectedPoints.size;
	            if (nonSelPointSizeValue) nonSelPointSizeValue.textContent = CONFIG.nonSelectedPoints.size;
	        }
	
	        if (opacitySlider) {
	            opacitySlider.min = CONFIG.selectedPoints.opacityMin;
	            opacitySlider.max = CONFIG.selectedPoints.opacityMax;
	            opacitySlider.step = CONFIG.selectedPoints.opacityStep;
	            opacitySlider.value = CONFIG.selectedPoints.opacity;
	            if (opacityValue) opacityValue.textContent = CONFIG.selectedPoints.opacity.toFixed(2);
	        }
	
	        if (nonSelOpacitySlider) {
	            nonSelOpacitySlider.min = CONFIG.nonSelectedPoints.opacityMin;
	            nonSelOpacitySlider.max = CONFIG.nonSelectedPoints.opacityMax;
	            nonSelOpacitySlider.step = CONFIG.nonSelectedPoints.opacityStep;
	            nonSelOpacitySlider.value = CONFIG.nonSelectedPoints.opacity;
	            if (nonSelOpacityValue) nonSelOpacityValue.textContent = CONFIG.nonSelectedPoints.opacity.toFixed(2);
	        }
	
	        if (speedSlider) {
	            speedSlider.min = CONFIG.movement.speedMin;
	            speedSlider.max = CONFIG.movement.speedMax;
	            speedSlider.step = CONFIG.movement.speedStep;
	            speedSlider.value = CONFIG.movement.speed;
	            if (speedValue) speedValue.textContent = CONFIG.movement.speed;
	        }
	
	        if (nonSelColorPicker) {
	            nonSelColorPicker.value = CONFIG.nonSelectedPoints.color;
	        }
	
	        if (bgColorPicker) {
	            bgColorPicker.value = CONFIG.rendering.clearColor;
	        }
	
	        // Selected point size
	        if (pointSizeSlider && pointSizeValue) {
	            pointSizeSlider.addEventListener('input', () => {
	                const v = parseFloat(pointSizeSlider.value);
	                pointSizeValue.textContent = v.toFixed(0);
	                this.pointCloud.state.setVisParam('selSize', v);
	            });
	        }
	
	        // Non-selected point size
	        if (nonSelPointSizeSlider && nonSelPointSizeValue) {
	            nonSelPointSizeSlider.addEventListener('input', () => {
	                const v = parseFloat(nonSelPointSizeSlider.value);
	                nonSelPointSizeValue.textContent = v.toFixed(0);
	                this.pointCloud.state.setVisParam('nonSelSize', v);
	            });
	        }
	
	        // Selected opacity
	        if (opacitySlider && opacityValue) {
	            opacitySlider.addEventListener('input', () => {
	                const v = parseFloat(opacitySlider.value);
	                opacityValue.textContent = v.toFixed(2);
	                this.pointCloud.state.setVisParam('selOp', v);
	            });
	        }
	
	        // Non-selected opacity
	        if (nonSelOpacitySlider && nonSelOpacityValue) {
	            nonSelOpacitySlider.addEventListener('input', () => {
	                const v = parseFloat(nonSelOpacitySlider.value);
	                nonSelOpacityValue.textContent = v.toFixed(2);
	                this.pointCloud.state.setVisParam('nonSelOp', v);
	            });
	        }
	
	        // Speed
	        if (speedSlider && speedValue) {
	            speedSlider.addEventListener('input', () => {
	                const v = parseFloat(speedSlider.value);
	                speedValue.textContent = v;
	                CONFIG.movement.speed = v;
	                this.pointCloud.settings.speed = v;
	                updateURL(); // Sync to URL
	            });
	        }
	
	        // Non-selected color
	        if (nonSelColorPicker) {
	            nonSelColorPicker.addEventListener('input', () => {
	                this.pointCloud.state.setVisParam('nonSelColor', nonSelColorPicker.value);
	            });
	        }
	
	        // Background color
	        if (bgColorPicker) {
	            bgColorPicker.addEventListener('input', () => {
	                this.pointCloud.state.setVisParam('bgColor', bgColorPicker.value);
	            });
	        }
	
	        // Randomize colors button
	        if (randomizeColorsBtn) {
	            randomizeColorsBtn.addEventListener('click', () => {
	                this.pointCloud.selMgr.randomizeColors();
	                this.pointCloud.state._fire('vis');
	            });
	        }
	
	        // Setup dropdowns
	        this._setupDropdowns();
	
	        /* keep renderer sized */
	        window.addEventListener('resize', () => {
	            this.pointCloud.camera.aspect = window.innerWidth / window.innerHeight;
	            this.pointCloud.camera.updateProjectionMatrix();
	            this.pointCloud.renderer.setSize(window.innerWidth, window.innerHeight);
	        });
	    }
	
	    _setupDropdowns() {
	        // Apply menu width from CONFIG
	        const controlsMenu = document.getElementById('controlsMenu');
	        if (controlsMenu) {
	            controlsMenu.style.minWidth = `${CONFIG.ui.menuWidth}px`;
	            controlsMenu.style.width = `${CONFIG.ui.menuWidth}px`;
	        }
	
	        const colorBySelect = document.getElementById('colorBySelect');
	        const selectBySelect = document.getElementById('selectBySelect');
	        const applyColumns = document.getElementById('applyColumns');
	
	        if (colorBySelect) {
	            // Clear existing options
	            colorBySelect.innerHTML = '';
	
	            // Populate color by dropdown
	            this.cats.forEach(col => {
	                const option = document.createElement('option');
	                option.value = col;
	                option.textContent = col;
	                colorBySelect.appendChild(option);
	            });
	
	            colorBySelect.value = this.pointCloud.state.colorBy;
	        }
	
	        if (selectBySelect) {
	            // Clear existing options
	            selectBySelect.innerHTML = '';
	
	            // Populate select by dropdown
	            this.cats.forEach(col => {
	                const option = document.createElement('option');
	                option.value = col;
	                option.textContent = col;
	                selectBySelect.appendChild(option);
	            });
	
	            selectBySelect.value = this.pointCloud.state.selectBy;
	        }
	
	        // Single Apply button for columns with loading notifications
	        if (applyColumns) {
	            applyColumns.addEventListener('click', async () => {
	                const sp = NOTIF.spinner('Updating columns...');
	
	                const newColorBy = colorBySelect.value;
	                const newSelectBy = selectBySelect.value;
	
	                // Check if changes are needed
	                const colorChanged = newColorBy !== this.pointCloud.state.colorBy;
	                const selectChanged = newSelectBy !== this.pointCloud.state.selectBy;
	
	                if (!colorChanged && !selectChanged) {
	                    sp.complete();
	                    NOTIF.show('No changes to apply', 2000);
	                    return;
	                }
	
	                try {
	                    // Give the UI time to render the spinner
	                    await new Promise(resolve => setTimeout(resolve, 50));
	
	                    // Clear caches first
	                    this.pointCloud.selMgr.clearCaches();
	
	                    // Apply color column change
	                    if (colorChanged) {
	                        this.pointCloud.state.setColorBy(newColorBy);
	                        this.colorIdx = Math.max(0, this.cats.indexOf(newColorBy));
	                    }
	
	                    // Apply selection column change
	                    if (selectChanged) {
	                        this.pointCloud.state.setSelectBy(newSelectBy);
	                        this.selectIdx = Math.max(0, this.cats.indexOf(newSelectBy));
	                    }
	
	                    // Give the UI another frame to update if needed
	                    await new Promise(resolve => setTimeout(resolve, 100));
	
	                    sp.complete();
	                    const changes = [];
	                    if (colorChanged) changes.push(`color: ${newColorBy}`);
	                    if (selectChanged) changes.push(`selection: ${newSelectBy}`);
	                    NOTIF.success(`Updated ${changes.join(', ')}`);
	
	                } catch (error) {
	                    sp.complete();
	                    NOTIF.error('Failed to update columns', error);
	                }
	            });
	        }
	
	        // Setup axis dropdowns
	        const xAxisSelect = document.getElementById('xAxisSelect');
	        const yAxisSelect = document.getElementById('yAxisSelect');
	        const zAxisSelect = document.getElementById('zAxisSelect');
	        const applyAxes = document.getElementById('applyAxes');
	
	        if (xAxisSelect && yAxisSelect && zAxisSelect) {
	            // Populate axis dropdowns with available PCA components
	            const numComponents = this.pointCloud.model.numericCols.length;
	            [xAxisSelect, yAxisSelect, zAxisSelect].forEach(select => {
	                select.innerHTML = '';
	                for (let i = 0; i < numComponents; i++) {
	                    const option = document.createElement('option');
	                    option.value = i;
	                    option.textContent = this.pointCloud.model.numericCols[i] || `PC${i}`;
	                    select.appendChild(option);
	                }
	            });
	
	            // Set current values from CONFIG
	            xAxisSelect.value = CONFIG.axes.x;
	            yAxisSelect.value = CONFIG.axes.y;
	            zAxisSelect.value = CONFIG.axes.z;
	        }
	
	        // Single Apply button for axes with notifications
	        if (applyAxes) {
	            applyAxes.addEventListener('click', async () => {
	                const maxIdx = this.pointCloud.model.numericCols.length - 1;
	                const clamp = (v) => Math.max(0, Math.min(v, maxIdx));
	                const newX = clamp(parseInt(xAxisSelect.value) || 0);
	                const newY = clamp(parseInt(yAxisSelect.value) || 0);
	                const newZ = clamp(parseInt(zAxisSelect.value) || 0);
	
	                // Check if changes are needed
	                const xChanged = newX !== CONFIG.axes.x;
	                const yChanged = newY !== CONFIG.axes.y;
	                const zChanged = newZ !== CONFIG.axes.z;
	
	                if (!xChanged && !yChanged && !zChanged) {
	                    NOTIF.show('No axis changes to apply', 2000);
	                    return;
	                }
	
	                const spinner = NOTIF.spinner('Updating visualization axes...');
	
	                try {
	                    // Give the UI time to render the spinner
	                    await new Promise(resolve => setTimeout(resolve, 50));
	
	                    // Apply axis changes
	                    this.pointCloud.state.setAxis('x', newX);
	                    this.pointCloud.state.setAxis('y', newY);
	                    this.pointCloud.state.setAxis('z', newZ);
	
	                    // Give UI another frame before the heavy _buildGeometry operation
	                    await new Promise(resolve => setTimeout(resolve, 10));
	
	                    this.pointCloud._buildGeometry();
	
	                    spinner.complete();
	
	                    const changes = [];
	                    if (xChanged) changes.push(`X: ${this.pointCloud.model.numericCols[newX]}`);
	                    if (yChanged) changes.push(`Y: ${this.pointCloud.model.numericCols[newY]}`);
	                    if (zChanged) changes.push(`Z: ${this.pointCloud.model.numericCols[newZ]}`);
	
	                    NOTIF.success(`Updated axes - ${changes.join(', ')}`);
	
	                } catch (error) {
	                    spinner.complete();
	                    NOTIF.error('Failed to update axes', error);
	                }
	            });
	        }
	
	        // Setup export config button
	        const exportBtn = document.getElementById('exportConfigBtn');
	        if (exportBtn) {
	            exportBtn.addEventListener('click', () => {
	                exportConfigToNewTab();
	                NOTIF.success('Configuration exported to new tab');
	            });
	        }
	
	        // Setup reset config button
	        const resetBtn = document.getElementById('resetConfigBtn');
	        if (resetBtn) {
	            resetBtn.addEventListener('click', async () => {
	                const spinner = NOTIF.spinner('Resetting configuration...');
	
	                try {
	                    // Give UI time to show spinner
	                    await new Promise(resolve => setTimeout(resolve, 50));
	
	                    // Reset config to loaded state and clear URL
	                    resetConfigToLoaded();
	
	                    // Trigger a page reload to apply the reset config
	                    // This is the cleanest way to ensure all state is properly reset
	                    window.location.reload();
	
	                } catch (error) {
	                    spinner.complete();
	                    NOTIF.error('Failed to reset configuration', error);
	                }
	            });
	        }
	    }
	
	
	    _updateColumnInfo() {
	        const colorByEl = document.getElementById('currentColorBy');
	        const selectByEl = document.getElementById('currentSelectBy');
	
	        if (colorByEl) colorByEl.textContent = this.pointCloud.state.colorBy;
	        if (selectByEl) selectByEl.textContent = this.pointCloud.state.selectBy;
	    }
	
	    _updateSelectedValuesDisplay() {
	        const container = document.getElementById('selectedValuesGrid');
	        const header = document.getElementById('selectedValuesHeader');
	        const metadata = document.getElementById('selectedValuesMetadata');
	
	        if (!container) return;
	
	        container.innerHTML = '';
	
	        const hasSelection = this.pointCloud.state.selection.size > 0;
	
	        if (hasSelection) {
	            // Show selected values
	            header.textContent = 'Selected Values:';
	
	            const selectedValues = Array.from(this.pointCloud.state.selection);
	
	            if (selectedValues.length <= CONFIG.ui.maxSelectedDisplay) {
	                selectedValues.forEach((value, index) => {
	                    const div = document.createElement('div');
	                    div.className = 'value-grid-item selected';
	
	                    const color = this.pointCloud.selMgr._getCategoricalColor(value);
	                    div.innerHTML = `
	                        <div class="value-grid-color" style="background-color: rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})"></div>
	                        <span style="flex: 1;">${value}</span>
	                        <span class="remove-btn" data-value="${value}"></span>
	                    `;
	
	                    container.appendChild(div);
	                });
	
	                metadata.textContent = `${selectedValues.length} selected`;
	            } else {
	                metadata.innerHTML = `${selectedValues.length} values selected<br>Too many to display individually`;
	            }
	        } else {
	            // Show message when no selection
	            header.textContent = 'No Selection';
	            metadata.textContent = 'Click items in the legend to select categories';
	        }
	    }
	
	    _updateLegendDisplay() {
	        const container = document.getElementById('legendGrid');
	        const header = document.getElementById('legendHeader');
	        const metadata = document.getElementById('legendMetadata');
	
	        if (!container) return;
	
	        container.innerHTML = '';
	
	        // Show legend
	        header.textContent = 'Legend:';
	
	        const colorColumn = this.pointCloud.state.colorBy;
	
	        if (this.pointCloud.state.isNumericColumn(colorColumn)) {
	            // Show colorbar info
	            const values = this.pointCloud.model.df.col(colorColumn).filter(v => typeof v === 'number' && !isNaN(v));
	            const min = Math.min(...values);
	            const max = Math.max(...values);
	
	            container.innerHTML = `
	                <div style="grid-column: 1 / -1;">
	                    <div style="font-size: 10px; margin-bottom: 4px;">${colorColumn}</div>
	                    <div class="colorbar"></div>
	                    <div class="colorbar-labels">
	                        <span>${min.toFixed(2)}</span>
	                        <span>${max.toFixed(2)}</span>
	                    </div>
	                </div>
	            `;
	            metadata.textContent = `Continuous scale: ${min.toFixed(2)} to ${max.toFixed(2)}`;
	        } else {
	            // Show categorical legend
	            const uniqueValues = [...this.pointCloud.model.df.col_unique(colorColumn)]
	                .filter(v => v !== null && v !== 'null' && v !== 'unknown')
	                .sort();
	
	            if (uniqueValues.length <= CONFIG.ui.maxCategoricalDisplay) {
	                uniqueValues.forEach(value => {
	                    const color = this.pointCloud.selMgr._getCategoricalColor(value);
	                    const div = document.createElement('div');
	                    div.className = 'value-grid-item legend-item-clickable';
	                    div.style.backgroundColor = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, 0.3)`;
	                    div.dataset.value = value;
	
	                    // Check if this value is currently selected
	                    const isSelected = this.pointCloud.state.selection.has(value);
	                    if (isSelected) {
	                        div.classList.add('selected');
	                    }
	
	                    div.innerHTML = `
	                        <div class="value-grid-color" style="background-color: rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})"></div>
	                        <span>${value}</span>
	                    `;
	
	                    container.appendChild(div);
	                });
	
	                metadata.textContent = `${uniqueValues.length} categories (click to select/deselect)`;
	            } else {
	                metadata.innerHTML = `${uniqueValues.length} categories<br>Too many to display individually`;
	            }
	        }
	    }
	
	    /* ---------- key bindings ---------------------------------- */
	    _bindKeys() {
	        document.addEventListener('keydown', e => {
	            /* panel toggles */
	            for (const [name, cfg] of Object.entries(this.uiConfig)) {
	                if (e.code === cfg.key) {
	                    e.preventDefault();
	                    this._togglePanel(name);
	                    // Update the corresponding shortcut status
	                    const shortcutEl = document.querySelector(`[data-action="${cfg.elementId}"]`);
	                    if (shortcutEl) {
	                        this._updatePanelStatusIndicator(shortcutEl, cfg.visible);
	                    }
	                }
	            }
	
	            /* colour / selection cycling */
	            if (e.code === 'KeyC') {
	                this.colorIdx = (this.colorIdx + 1) % this.cats.length;
	                this.pointCloud.state.setColorBy(this.cats[this.colorIdx]);
	                // Update dropdown
	                const colorBySelect = document.getElementById('colorBySelect');
	                if (colorBySelect) colorBySelect.value = this.cats[this.colorIdx];
	            }
	            if (e.code === 'KeyV') {
	                this.selectIdx = (this.selectIdx + 1) % this.cats.length;
	                this.pointCloud.state.setSelectBy(this.cats[this.selectIdx]);
	                // Update dropdown
	                const selectBySelect = document.getElementById('selectBySelect');
	                if (selectBySelect) selectBySelect.value = this.cats[this.selectIdx];
	            }
	
	            /* hover UI toggle */
	            if (e.code === 'KeyK') {
	                CONFIG.interaction.hoverActive = !CONFIG.interaction.hoverActive;
	                this.pointCloud.hoverActive = CONFIG.interaction.hoverActive;
	                this._updateStatusIndicator('hover-status', CONFIG.interaction.hoverActive);
	                if (!CONFIG.interaction.hoverActive) this.hoverPanel.style.display = 'none';
	                updateURL(); // Sync to URL
	            }
	
	            /* click-select toggle */
	            if (e.code === 'KeyB') {
	                CONFIG.interaction.selectOnClick = !CONFIG.interaction.selectOnClick;
	                this.pointCloud.selectOnClick = CONFIG.interaction.selectOnClick;
	                this._updateStatusIndicator('click-select-status', CONFIG.interaction.selectOnClick);
	                updateURL(); // Sync to URL
	            }
	
	            /* right-click toggle */
	            if (e.code === 'KeyO') {
	                CONFIG.interaction.rightClickActive = !CONFIG.interaction.rightClickActive;
	                this.pointCloud.rightClickActive = CONFIG.interaction.rightClickActive;
	                this._updateStatusIndicator('right-click-status', CONFIG.interaction.rightClickActive);
	                updateURL(); // Sync to URL
	            }
	
	            /* middle-click toggle */
	            if (e.code === 'KeyP') {
	                CONFIG.middleClick.enabled = !CONFIG.middleClick.enabled;
	                this._updateStatusIndicator('middle-click-status', CONFIG.middleClick.enabled);
	                updateURL(); // Sync to URL
	            }
	        });
	    }
	
	    _togglePanel(name) {
	        const cfg = this.uiConfig[name];
	        cfg.visible = !cfg.visible;
	
	        // Update CONFIG to keep it in sync
	        CONFIG.panels[name] = cfg.visible;
	        updateURL(); // Sync to URL
	
	        document.getElementById(cfg.elementId).style.display = cfg.visible ? 'block' : 'none';
	    }
	
	    _updateStatusIndicator(elementId, enabled) {
	        const statusEl = document.getElementById(elementId);
	        statusEl.textContent = enabled ? '(enabled)' : '(disabled)';
	        statusEl.className = `status-indicator ${enabled ? 'status-enabled' : 'status-disabled'}`;
	    }
	
	    _updatePanelStatusIndicator(element, visible) {
	        const statusEl = element.querySelector('.status-indicator');
	        statusEl.textContent = visible ? '(enabled)' : '(disabled)';
	        statusEl.className = `status-indicator ${visible ? 'status-enabled' : 'status-disabled'}`;
	    }
	
	    /* ---------- per-frame UI refresh ------------------------------ */
	    updateUI() {
	        /* navbar + navball */
	        if (this.uiConfig.navbar.visible) {
	            const p = this.pointCloud.camera.position;
	            ['posX', 'posY', 'posZ'].forEach((id, i) =>
	                document.getElementById(id).textContent =
	                p[['x', 'y', 'z'][i]].toFixed(1));
	            this.navball.syncWithCameraQuaternion(
	                this.pointCloud.camera.quaternion);
	        }
	
	        /* stats */
	        if (this.uiConfig.stats.visible) this._updateStats();
	
	        /* hover tooltip */
	        this._showHover(this.pointCloud.hoverId);
	
	        /* current "Color by / Select by" labels */
	        this._updateColumnInfo();
	
	        /* performance monitoring */
	        this._checkPerformance();
	    }
	
	    /* ---------- FPS / stats ----------------------------------- */
	    _updateStats() {
	        this._tickFPS();
	        const ms = (1000 / Math.max(this.fps, 1)).toFixed(1) + ' ms';
	
	        document.getElementById('fps').textContent = this.fps;
	        document.getElementById('frameTime').textContent = ms;
	        document.getElementById('renderedCount').textContent =
	            this.pointCloud.points.geometry.getAttribute('position').count;
	
	        const p = this.pointCloud.camera.position;
	        document.getElementById('statsPosX').textContent = p.x.toFixed(3);
	        document.getElementById('statsPosY').textContent = p.y.toFixed(3);
	        document.getElementById('statsPosZ').textContent = p.z.toFixed(3);
	    }
	
	    _tickFPS() {
	        this.frameCount++;
	        const now = performance.now();
	        if (now - this.lastTime >= 1000) {
	            this.fps = Math.round(this.frameCount * 1000 / (now - this.lastTime));
	            this.frameCount = 0;
	            this.lastTime = now;
	        }
	    }
	
	    onPointsRegenerated() {
	        if (this.uiConfig.stats.visible)
	            document.getElementById('renderedCount').textContent =
	                this.pointCloud.points.geometry.getAttribute('position').count;
	    }
	
	    /* ---------- hover tooltip --------------------------------- */
	    _showHover(id) {
	        if (!CONFIG.interaction.hoverActive || id == null) {
	            this.hoverPanel.style.display = 'none';
	            return;
	        }
	
	        const row = this.pointCloud.model.row(id);
	        const a = this.pointCloud.state.axis;
	        const xyz = [
	            this.pointCloud.model.getCoord(id, a.x).toFixed(2),
	            this.pointCloud.model.getCoord(id, a.y).toFixed(2),
	            this.pointCloud.model.getCoord(id, a.z).toFixed(2)
	        ];
	        const html = CONFIG.hoverColumns
	            .map(c => `<b>${c}</b>: ${row[c]}`)
	            .concat([`<b>coord</b>: [${xyz.join(', ')}]`])
	            .join('<br>');
	
	        this.hoverPanel.innerHTML = html;
	        const { x, y } = this.pointCloud.pointerScreen;
	        this.hoverPanel.style.left = (x + CONFIG.ui.hoverOffset.x) + 'px';
	        this.hoverPanel.style.top = (y + CONFIG.ui.hoverOffset.y) + 'px';
	        this.hoverPanel.style.display = 'block';
	    }
	
	    _checkPerformance() {
	        const now = performance.now();
	
	        // Only check every interval from CONFIG
	        if (now - this.lastPerformanceCheck < this.performanceCheckInterval) {
	            return;
	        }
	
	        this.lastPerformanceCheck = now;
	
	        // Check if FPS is consistently low
	        if (this.fps < this.fpsThreshold && !this.performanceWarningShown) {
	            this.performanceWarningShown = true;
	            this._optimizeForPerformance();
	
	            // Reset the flag after cooldown from CONFIG
	            setTimeout(() => {
	                this.performanceWarningShown = false;
	            }, CONFIG.performance.performanceOptimizationCooldown);
	        }
	    }
	
	    _optimizeForPerformance() {
	        let changesApplied = [];
	
	        // Force full opacity
	        const opacitySlider = document.getElementById('opacity');
	        const nonSelOpacitySlider = document.getElementById('nonSelOpacity');
	        const opacityValue = document.getElementById('opacityValue');
	        const nonSelOpacityValue = document.getElementById('nonSelOpacityValue');
	
	        if (opacitySlider && parseFloat(opacitySlider.value) < 1.0) {
	            opacitySlider.value = '1.0';
	            opacityValue.textContent = '1.00';
	            this.pointCloud.state.setVisParam('selOp', 1.0);
	            changesApplied.push('selected opacity to 100%');
	        }
	
	        if (nonSelOpacitySlider && parseFloat(nonSelOpacitySlider.value) < 1.0) {
	            nonSelOpacitySlider.value = '1.0';
	            nonSelOpacityValue.textContent = '1.00';
	            this.pointCloud.state.setVisParam('nonSelOp', 1.0);
	            changesApplied.push('non-selected opacity to 100%');
	        }
	
	        // Limit point sizes to max 5
	        const pointSizeSlider = document.getElementById('pointSize');
	        const nonSelPointSizeSlider = document.getElementById('nonSelPointSize');
	        const pointSizeValue = document.getElementById('pointSizeValue');
	        const nonSelPointSizeValue = document.getElementById('nonSelPointSizeValue');
	
	        if (pointSizeSlider && parseFloat(pointSizeSlider.value) > 5) {
	            pointSizeSlider.value = '5';
	            pointSizeValue.textContent = '5';
	            this.pointCloud.state.setVisParam('selSize', 5);
	            changesApplied.push('selected point size to 5');
	        }
	
	        if (nonSelPointSizeSlider && parseFloat(nonSelPointSizeSlider.value) > 5) {
	            nonSelPointSizeSlider.value = '5';
	            nonSelPointSizeValue.textContent = '5';
	            this.pointCloud.state.setVisParam('nonSelSize', 5);
	            changesApplied.push('non-selected point size to 5');
	        }
	
	        // Show error notification using NOTIF system
	        if (changesApplied.length > 0) {
	            const message = `Performance warning: Low FPS detected (${this.fps}). Adjusted: ${changesApplied.join(', ')}.`;
	            NOTIF.error(message, null, CONFIG.performance.performanceWarningDuration);
	        }
	    }
	}
	</script>
	<!-- end 'ui.js' -->
		<!-- begin 'PointCloud.js' -->
	<script>
	/* PointCloud.js  Enhanced with mobile touch controls for pinch zoom, pan, tap, and hold */
	
	class PointCloud {
	    /** @param {DataModel} model */
	    constructor(model) {
	        this.model = model;
	
	        /*  THREE basics - using CONFIG values  */
	        this.scene = new THREE.Scene();
	        this.camera = new THREE.PerspectiveCamera(
	            CONFIG.rendering.cameraFov,
	            window.innerWidth / window.innerHeight,
	            CONFIG.rendering.cameraNear,
	            CONFIG.rendering.cameraFar
	        );
	        this.renderer = new THREE.WebGLRenderer({ antialias: CONFIG.rendering.antialiasing });
	
	        /*  picking helpers  */
	        this.raycaster = new THREE.Raycaster();
	        this.raycaster.params.Points = { threshold: CONFIG.interaction.raycastThreshold };
	        this.pointerNDC = new THREE.Vector2();
	        this.pointerScreen = { x: 0, y: 0 };
	
	        this.hoverId = null;
	        this.prevHoverId = null;
	
	        /*  behaviour flags (from CONFIG)  */
	        this.hoverActive = CONFIG.interaction.hoverActive;
	        this.selectOnClick = CONFIG.interaction.selectOnClick;
	        this.rightClickActive = CONFIG.interaction.rightClickActive;
	
	        /*  mobile touch state  */
	        this.touchState = {
	            touching: false,
	            touches: new Map(), // trackingId -> {x, y, startTime}
	            lastDistance: 0,
	            isPinching: false,
	            isPanning: false,
	            panDisablesInteraction: false,
	            singleTapTimer: null,
	            holdTimer: null,
	            lastTapTime: 0,
	            tapThreshold: 200, // ms for tap vs hold
	            doubleTapThreshold: 300, // ms for double tap detection
	            holdThreshold: 500, // ms for hold detection
	            moveThreshold: 10, // pixels before it's considered a drag
	            zoomSensitivity: 0.01,
	            panSensitivity: 0.002
	        };
	
	        /*  info box state (middle-click)  */
	        this.infoBoxes = new Map();
	        this.infoBoxIdCounter = 0;
	        this.infoBoxDragging = null;
	
	        /*  colour / selection state  */
	        this.state = new VisState(model);
	        this.selMgr = new SelectionManager(model, this.state);
	        this.state.addEventListener('selection', () => this._updateColors());
	        this.state.addEventListener('vis', () => {
	            this._updateColors();
	            this.renderer.setClearColor(this.state.bgColor);
	        });
	
	        /*  viewer settings - using CONFIG  */
	        this.settings = {
	            pointSize: 0.1,
	            opacity: 0.8,
	            speed: CONFIG.movement.speed
	        };
	
	        /*  movement bookkeeping  */
	        this.keys = {};
	        this.pitch = CONFIG.camera.rotation.pitch; // Initialize from CONFIG
	        this.mouseDX = 0;
	        this.mouseDY = 0;
	        this.rollSpeed = CONFIG.movement.rollSpeed;
	        this.velocity = new THREE.Vector3();
	
	        /* camera sync debouncing */
	        this.cameraSyncTimeout = null;
	        this.cameraSyncDelay = 1000; // Sync camera to URL after 1 second of no movement
	
	        /*  cross-hair objects  */
	        this.crossH = null;
	        this.crossV = null;
	        this._createCrosshairs();
	
	        /* bootstrap */
	        this._init();
	    }
	
	    /* ---------- input & interaction -------------------------- */
	    _setupInput() {
	        /* keyboard state */
	        document.addEventListener('keydown', e => this.keys[e.code] = true);
	        document.addEventListener('keyup', e => this.keys[e.code] = false);
	
	        /* mouse movement */
	        document.addEventListener('mousemove', e => {
	            if (document.pointerLockElement === document.body) {
	                this.mouseDX += e.movementX;
	                this.mouseDY += e.movementY;
	            }
	            this._updatePointerPosition(e.clientX, e.clientY);
	        });
	
	        /* click-to-select (can be disabled) */
	        window.addEventListener('click', (e) => {
	            // Don't process clicks during touch interactions
	            if (this.touchState.panDisablesInteraction) return;
	
	            if (!this.selectOnClick || this.hoverId === null) return;
	            const v = this.model.row(this.hoverId)[this.state.selectBy];
	            this.state.toggleValue(v);
	        });
	
	        /* right-click handler */
	        window.addEventListener('contextmenu', (e) => {
	            if (!this.rightClickActive || this.hoverId === null) return;
	            e.preventDefault(); // Prevent default context menu
	
	            const row = this.model.row(this.hoverId);
	            this._handleRightClick(row, this.hoverId);
	        });
	
	        /* middle-click handler for info boxes */
	        window.addEventListener('auxclick', (e) => {
	            if (e.button !== 1) return;
	            e.preventDefault();
	            const infoBox = e.target.closest('.info-box');
	            if (infoBox) {
	                this._removeInfoBox(parseInt(infoBox.dataset.boxId));
	                return;
	            }
	            if (!CONFIG.middleClick.enabled || this.hoverId === null) return;
	            const row = this.model.row(this.hoverId);
	            this._createInfoBox(row, this.hoverId, e.clientX, e.clientY);
	        });
	
	        /* info box dragging */
	        window.addEventListener('mousedown', (e) => {
	            if (e.button !== 0) return;
	            const header = e.target.closest('.info-box-header');
	            if (!header) return;
	            const infoBox = header.closest('.info-box');
	            if (!infoBox) return;
	            const rect = infoBox.getBoundingClientRect();
	            this.infoBoxDragging = {
	                boxId: parseInt(infoBox.dataset.boxId),
	                offsetX: e.clientX - rect.left,
	                offsetY: e.clientY - rect.top
	            };
	            e.preventDefault();
	        });
	
	        window.addEventListener('mousemove', (e) => {
	            if (!this.infoBoxDragging) return;
	            const box = this.infoBoxes.get(this.infoBoxDragging.boxId);
	            if (!box) return;
	            box.element.style.left = (e.clientX - this.infoBoxDragging.offsetX) + 'px';
	            box.element.style.top = (e.clientY - this.infoBoxDragging.offsetY) + 'px';
	            this._updateInfoBoxLine(this.infoBoxDragging.boxId);
	        });
	
	        window.addEventListener('mouseup', () => {
	            this.infoBoxDragging = null;
	        });
	
	        /*  Touch event handlers  */
	        this._setupTouchEvents();
	
	        /* pointer-lock helpers */
	        document.addEventListener('dblclick', () => {
	            (document.pointerLockElement === document.body)
	                ? document.exitPointerLock()
	                : document.body.requestPointerLock();
	        });
	        document.addEventListener('keydown', e => {
	            if (e.code === 'Escape' && document.pointerLockElement === document.body)
	                document.exitPointerLock();
	        });
	
	        /* resize */
	        window.addEventListener('resize', () => {
	            this.camera.aspect = window.innerWidth / window.innerHeight;
	            this.camera.updateProjectionMatrix();
	            this.renderer.setSize(window.innerWidth, window.innerHeight);
	        });
	    }
	
	    _setupTouchEvents() {
	        const canvas = this.renderer.domElement;
	
	        // Prevent default touch behaviors that interfere with our controls
	        canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
	        canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
	        canvas.addEventListener('touchend', e => e.preventDefault(), { passive: false });
	
	        canvas.addEventListener('touchstart', this._onTouchStart.bind(this));
	        canvas.addEventListener('touchmove', this._onTouchMove.bind(this));
	        canvas.addEventListener('touchend', this._onTouchEnd.bind(this));
	        canvas.addEventListener('touchcancel', this._onTouchEnd.bind(this));
	    }
	
	    _onTouchStart(event) {
	        const now = performance.now();
	        this.touchState.touching = true;
	
	        // Update touch tracking
	        for (const touch of event.touches) {
	            this.touchState.touches.set(touch.identifier, {
	                x: touch.clientX,
	                y: touch.clientY,
	                startX: touch.clientX,
	                startY: touch.clientY,
	                startTime: now
	            });
	        }
	
	        const touchCount = event.touches.length;
	
	        if (touchCount === 1) {
	            // Single touch - potential tap, hold, or pan start
	            const touch = event.touches[0];
	            this._updatePointerPosition(touch.clientX, touch.clientY);
	
	            // Set up hold timer
	            this.touchState.holdTimer = setTimeout(() => {
	                this._onTouchHold(touch);
	            }, this.touchState.holdThreshold);
	
	            // Check for double tap
	            const timeSinceLastTap = now - this.touchState.lastTapTime;
	            if (timeSinceLastTap < this.touchState.doubleTapThreshold) {
	                this._onDoubleTap(touch);
	                this.touchState.lastTapTime = 0; // Reset to prevent triple tap
	            }
	
	        } else if (touchCount === 2) {
	            // Two touches - pinch zoom setup
	            this._clearTouchTimers();
	            this.touchState.isPinching = true;
	            this.touchState.panDisablesInteraction = true;
	
	            const touch1 = event.touches[0];
	            const touch2 = event.touches[1];
	            this.touchState.lastDistance = this._getTouchDistance(touch1, touch2);
	        }
	    }
	
	    _onTouchMove(event) {
	        if (!this.touchState.touching) return;
	
	        const touchCount = event.touches.length;
	
	        if (touchCount === 1 && !this.touchState.isPinching) {
	            // Single touch movement - pan or cancel tap
	            const touch = event.touches[0];
	            const stored = this.touchState.touches.get(touch.identifier);
	
	            if (stored) {
	                const moveDistance = Math.sqrt(
	                    Math.pow(touch.clientX - stored.startX, 2) +
	                    Math.pow(touch.clientY - stored.startY, 2)
	                );
	
	                // If moved beyond threshold, start panning
	                if (moveDistance > this.touchState.moveThreshold) {
	                    this._clearTouchTimers(); // Cancel tap/hold
	                    this.touchState.isPanning = true;
	                    this.touchState.panDisablesInteraction = true;
	
	                    // Apply pan rotation
	                    const deltaX = touch.clientX - stored.x;
	                    const deltaY = touch.clientY - stored.y;
	
	                    this._applyTouchPan(deltaX, deltaY);
	                }
	
	                // Update stored position
	                stored.x = touch.clientX;
	                stored.y = touch.clientY;
	                this._updatePointerPosition(touch.clientX, touch.clientY);
	            }
	
	        } else if (touchCount === 2 && this.touchState.isPinching) {
	            // Two finger pinch zoom
	            const touch1 = event.touches[0];
	            const touch2 = event.touches[1];
	            const distance = this._getTouchDistance(touch1, touch2);
	
	            if (this.touchState.lastDistance > 0) {
	                const deltaDistance = distance - this.touchState.lastDistance;
	                this._applyTouchZoom(deltaDistance);
	            }
	
	            this.touchState.lastDistance = distance;
	
	            // Update touch positions
	            this.touchState.touches.set(touch1.identifier, {
	                ...this.touchState.touches.get(touch1.identifier),
	                x: touch1.clientX,
	                y: touch1.clientY
	            });
	            this.touchState.touches.set(touch2.identifier, {
	                ...this.touchState.touches.get(touch2.identifier),
	                x: touch2.clientX,
	                y: touch2.clientY
	            });
	        }
	    }
	
	    _onTouchEnd(event) {
	        const now = performance.now();
	
	        // Remove ended touches from tracking
	        const activeTouchIds = new Set(Array.from(event.touches).map(t => t.identifier));
	        for (const [id] of this.touchState.touches) {
	            if (!activeTouchIds.has(id)) {
	                const stored = this.touchState.touches.get(id);
	
	                // Check if this was a quick tap (not moved, not held)
	                if (stored && !this.touchState.isPanning && !this.touchState.isPinching) {
	                    const duration = now - stored.startTime;
	                    const moveDistance = Math.sqrt(
	                        Math.pow(stored.x - stored.startX, 2) +
	                        Math.pow(stored.y - stored.startY, 2)
	                    );
	
	                    if (duration < this.touchState.tapThreshold &&
	                        moveDistance < this.touchState.moveThreshold) {
	                        this._onSingleTap(stored);
	                    }
	                }
	
	                this.touchState.touches.delete(id);
	            }
	        }
	
	        // Reset states when no touches remain
	        if (event.touches.length === 0) {
	            this.touchState.touching = false;
	            this.touchState.isPinching = false;
	
	            // Re-enable interaction after a short delay to prevent accidental clicks
	            setTimeout(() => {
	                this.touchState.isPanning = false;
	                this.touchState.panDisablesInteraction = false;
	            }, 100);
	
	            this._clearTouchTimers();
	        }
	    }
	
	    _onSingleTap(touchData) {
	        // Single tap acts like hover - update pointer and show hover info
	        this._updatePointerPosition(touchData.x, touchData.y);
	        this.touchState.lastTapTime = performance.now();
	
	        // Briefly show hover for touch devices
	        if (this.hoverActive && this.hoverId !== null) {
	            // Force a hover update
	            this._updateCrosshairs(this.hoverId);
	        }
	    }
	
	    _onDoubleTap(touch) {
	        // Double tap acts like click-to-select
	        this._clearTouchTimers();
	
	        if (this.selectOnClick && this.hoverId !== null) {
	            const v = this.model.row(this.hoverId)[this.state.selectBy];
	            this.state.toggleValue(v);
	        }
	    }
	
	    _onTouchHold(touch) {
	        // Hold acts like right-click
	        if (this.rightClickActive && this.hoverId !== null) {
	            const row = this.model.row(this.hoverId);
	            this._handleRightClick(row, this.hoverId);
	        }
	    }
	
	    _applyTouchPan(deltaX, deltaY) {
	        const sens = this.touchState.panSensitivity;
	        const yaw = -deltaX * sens;
	        const pitchDelta = -deltaY * sens;
	
	        if (yaw) {
	            this.camera.rotateY(yaw);
	            CONFIG.camera.rotation.yaw += yaw;
	            this._debounceCameraSync();
	        }
	        if (pitchDelta) {
	            const newPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch + pitchDelta));
	            this.camera.rotateX(newPitch - this.pitch);
	            this.pitch = newPitch;
	            CONFIG.camera.rotation.pitch = this.pitch;
	            this._debounceCameraSync();
	        }
	    }
	
	    _applyTouchZoom(deltaDistance) {
	        // Convert pinch distance to forward/backward movement
	        const zoomAmount = deltaDistance * this.touchState.zoomSensitivity;
	
	        // Move camera forward/backward along its local Z axis
	        const zoomVector = new THREE.Vector3(0, 0, -zoomAmount);
	        zoomVector.applyQuaternion(this.camera.quaternion);
	        this.camera.position.add(zoomVector);
	
	        // Update CONFIG to sync position to URL
	        CONFIG.camera.position.x = this.camera.position.x;
	        CONFIG.camera.position.y = this.camera.position.y;
	        CONFIG.camera.position.z = this.camera.position.z;
	        this._debounceCameraSync();
	    }
	
	    _getTouchDistance(touch1, touch2) {
	        const dx = touch1.clientX - touch2.clientX;
	        const dy = touch1.clientY - touch2.clientY;
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    _updatePointerPosition(x, y) {
	        this.pointerScreen.x = x;
	        this.pointerScreen.y = y;
	        this.pointerNDC.x = (x / window.innerWidth) * 2 - 1;
	        this.pointerNDC.y = -(y / window.innerHeight) * 2 + 1;
	    }
	
	    _clearTouchTimers() {
	        if (this.touchState.singleTapTimer) {
	            clearTimeout(this.touchState.singleTapTimer);
	            this.touchState.singleTapTimer = null;
	        }
	        if (this.touchState.holdTimer) {
	            clearTimeout(this.touchState.holdTimer);
	            this.touchState.holdTimer = null;
	        }
	    }
	
	    /* ---------- right-click handling and template system ----- */
	    _handleRightClick(row, pointId) {
	        const templateData = this._buildTemplateData(row, pointId);
	
	        if (CONFIG.rightClick.mode === "content") {
	            this._openContentTab(templateData);
	        } else if (CONFIG.rightClick.mode === "url") {
	            this._openUrlTab(templateData);
	        }
	    }
	
	    _buildTemplateData(row, pointId) {
	        const a = this.state.axis;
	        const coords = {
	            x: this.model.getCoord(pointId, a.x).toFixed(3),
	            y: this.model.getCoord(pointId, a.y).toFixed(3),
	            z: this.model.getCoord(pointId, a.z).toFixed(3)
	        };
	
	        return {
	            // All row data (flattened with dot notation for nested objects)
	            ...this._flattenObject(row),
	
	            // Point index (for image filenames, etc.)
	            '_index': pointId,
	
	            // Coordinate data
	            'coord.x': coords.x,
	            'coord.y': coords.y,
	            'coord.z': coords.z,
	
	            // Axis information
	            'axis.x.name': this.model.numericCols[a.x],
	            'axis.x.index': a.x,
	            'axis.y.name': this.model.numericCols[a.y],
	            'axis.y.index': a.y,
	            'axis.z.name': this.model.numericCols[a.z],
	            'axis.z.index': a.z,
	
	            // Config data (flattened)
	            ...this._flattenObject(CONFIG, 'config.')
	        };
	    }
	
	    _flattenObject(obj, prefix = '') {
	        const flattened = {};
	
	        for (const key in obj) {
	            const value = obj[key];
	            const newKey = prefix + key;
	
	            if (value && typeof value === 'object' && !Array.isArray(value)) {
	                Object.assign(flattened, this._flattenObject(value, newKey + '.'));
	            } else {
	                flattened[newKey] = value;
	            }
	        }
	
	        return flattened;
	    }
	
	    _replaceTemplate(template, data) {
	        return template.replace(/\{([^}]+)\}/g, (match, key) => {
	            const value = data[key];
	            if (value !== undefined && value !== null) {
	                return String(value);
	            }
	            return match; // Keep original if no replacement found
	        });
	    }
	
	    _openContentTab(templateData) {
	        const title = this._replaceTemplate(CONFIG.rightClick.content.title, templateData);
	        const content = this._replaceTemplate(CONFIG.rightClick.content.template, templateData);
	
	        // Create HTML content with monospace styling
	        const htmlContent = `<!DOCTYPE html>
	<html>
	<head>
		<title>${this._escapeHtml(title)}</title>
		<style>
			body {
				font-family: 'Courier New', monospace;
				background: #000;
				color: #00ff00;
				padding: 20px;
				margin: 0;
				white-space: pre-wrap;
				line-height: 1.4;
			}
		</style>
	</head>
	<body>${this._escapeHtml(content)}</body>
	</html>`;
	
	        const blob = new Blob([htmlContent], { type: 'text/html' });
	        const url = URL.createObjectURL(blob);
	        const newWindow = window.open(url, '_blank');
	
	        // Clean up after a delay
	        setTimeout(() => URL.revokeObjectURL(url), 1000);
	    }
	
	    _openUrlTab(templateData) {
	        const url = this._replaceTemplate(CONFIG.rightClick.url.template, templateData);
	
	        // URL encode the final URL to handle special characters
	        try {
	            window.open(url, '_blank');
	        } catch (error) {
	            console.error('Failed to open URL:', url, error);
	            NOTIF.error(`Failed to open URL: ${url}`);
	        }
	    }
	
	    _escapeHtml(text) {
	        const div = document.createElement('div');
	        div.textContent = text;
	        return div.innerHTML;
	    }
	
	    /* ---------- info box methods (middle-click) ------------- */
	    _createInfoBox(row, pointId, clickX, clickY) {
	        const boxId = this.infoBoxIdCounter++;
	        const templateData = this._buildTemplateData(row, pointId);
	        const title = this._replaceTemplate(CONFIG.middleClick.title, templateData);
	        const content = this._replaceTemplate(CONFIG.middleClick.content, templateData);
	
	        const box = document.createElement('div');
	        box.className = 'info-box';
	        box.dataset.boxId = boxId;
	        box.style.left = clickX + 'px';
	        box.style.top = clickY + 'px';
	        box.innerHTML = `
	            <div class="info-box-header">
	                <span class="info-box-title">${this._escapeHtml(title)}</span>
	                <span class="info-box-close"></span>
	            </div>
	            <div class="info-box-content">${content}</div>`;
	        box.querySelector('.info-box-close').addEventListener('click', (e) => { e.stopPropagation(); this._removeInfoBox(boxId); });
	        box.querySelector('.info-box-title').addEventListener('click', (e) => { e.stopPropagation(); this._handleRightClick(row, pointId); });
	        document.getElementById('info-boxes').appendChild(box);
	
	        const svg = document.getElementById('info-box-lines');
	        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	        line.classList.add('info-box-line');
	        line.dataset.boxId = boxId;
	        svg.appendChild(line);
	
	        const anchor = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	        anchor.classList.add('info-box-anchor');
	        anchor.setAttribute('r', '4');
	        anchor.dataset.boxId = boxId;
	        svg.appendChild(anchor);
	
	        this.infoBoxes.set(boxId, { element: box, lineElement: line, anchorElement: anchor, pointId, row });
	        this._updateInfoBoxLine(boxId);
	    }
	
	    _removeInfoBox(boxId) {
	        const box = this.infoBoxes.get(boxId);
	        if (!box) return;
	        box.element.remove();
	        box.lineElement.remove();
	        box.anchorElement.remove();
	        this.infoBoxes.delete(boxId);
	    }
	
	    _updateInfoBoxLine(boxId) {
	        const box = this.infoBoxes.get(boxId);
	        if (!box) return;
	        const a = this.state.axis;
	        const pointPos = new THREE.Vector3(
	            this.model.getCoord(box.pointId, a.x),
	            this.model.getCoord(box.pointId, a.y),
	            this.model.getCoord(box.pointId, a.z)
	        );
	        pointPos.project(this.camera);
	        const pointX = (pointPos.x * 0.5 + 0.5) * window.innerWidth;
	        const pointY = (-pointPos.y * 0.5 + 0.5) * window.innerHeight;
	        const rect = box.element.getBoundingClientRect();
	        box.lineElement.setAttribute('x1', pointX);
	        box.lineElement.setAttribute('y1', pointY);
	        box.lineElement.setAttribute('x2', rect.left);
	        box.lineElement.setAttribute('y2', rect.top + rect.height / 2);
	        box.anchorElement.setAttribute('cx', pointX);
	        box.anchorElement.setAttribute('cy', pointY);
	    }
	
	    _updateAllInfoBoxLines() {
	        for (const boxId of this.infoBoxes.keys()) {
	            this._updateInfoBoxLine(boxId);
	        }
	    }
	
	    /* ========================================================= */
	    _init() {
	        this._setupRenderer();
	        this._setupInput();
	        this._buildGeometry();
	        this._animate();
	    }
	
	    _setupRenderer() {
	        this.renderer.setSize(window.innerWidth, window.innerHeight);
	        this.renderer.setClearColor(this.state.bgColor);
	        document.getElementById('container').appendChild(this.renderer.domElement);
	
	        // Set camera position and rotation from CONFIG
	        this.camera.position.set(
	            CONFIG.camera.position.x,
	            CONFIG.camera.position.y,
	            CONFIG.camera.position.z
	        );
	
	        // Apply rotation (yaw, pitch, roll)
	        this.camera.rotation.set(0, 0, 0); // Reset first
	        this.camera.rotateY(CONFIG.camera.rotation.yaw);
	        this.camera.rotateX(CONFIG.camera.rotation.pitch);
	        this.camera.rotateZ(CONFIG.camera.rotation.roll);
	
	        // Set internal pitch tracking to match config
	        this.pitch = CONFIG.camera.rotation.pitch;
	    }
	
	    /* ---------- in-scene cross-hair - using CONFIG ----------- */
	    _createCrosshairs() {
	        const mat = new THREE.LineBasicMaterial({
	            color: CONFIG.crosshair.color,
	            transparent: true,
	            opacity: CONFIG.crosshair.opacity,
	            depthTest: false
	        });
	
	        /* horizontal (X-axis) */
	        const gH = new THREE.BufferGeometry().setFromPoints([
	            new THREE.Vector3(-CONFIG.crosshair.length, 0, 0),
	            new THREE.Vector3(CONFIG.crosshair.length, 0, 0)
	        ]);
	        this.crossH = new THREE.Line(gH, mat);
	        this.crossH.visible = false;
	        this.scene.add(this.crossH);
	
	        /* vertical (Y-axis) */
	        const gV = new THREE.BufferGeometry().setFromPoints([
	            new THREE.Vector3(0, -CONFIG.crosshair.length, 0),
	            new THREE.Vector3(0, CONFIG.crosshair.length, 0)
	        ]);
	        this.crossV = new THREE.Line(gV, mat);
	        this.crossV.visible = false;
	        this.scene.add(this.crossV);
	    }
	
	    _updateCrosshairs(id) {
	        if (!this.hoverActive || id === null) {
	            this.crossH.visible = this.crossV.visible = false;
	            return;
	        }
	        const a = this.state.axis;
	        const x = this.model.getCoord(id, a.x);
	        const y = this.model.getCoord(id, a.y);
	        const z = this.model.getCoord(id, a.z);
	
	        this.crossH.position.set(0, y, z);
	        this.crossV.position.set(x, 0, z);
	        this.crossH.visible = this.crossV.visible = true;
	    }
	
	    /* ---------- build / rebuild point geometry --------------- */
	    _buildGeometry() {
	        if (this.points) {
	            this.scene.remove(this.points);
	            this.points.geometry.dispose();
	            this.points.material.dispose();
	        }
	
	        const pos = [];
	        const col = [];
	        const sizes = [];
	        const opacities = [];
	
	        const a = this.state.axis;
	        for (let i = 0; i < this.model.rowCount; ++i) {
	            pos.push(
	                this.model.getCoord(i, a.x),
	                this.model.getCoord(i, a.y),
	                this.model.getCoord(i, a.z)
	            );
	            col.push(0.6, 0.6, 0.6);
	            sizes.push(1.0); // Default size, will be updated in _updateColors
	            opacities.push(1.0); // Default opacity, will be updated in _updateColors
	        }
	
	        const geom = new THREE.BufferGeometry();
	        geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
	        geom.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
	        geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
	        geom.setAttribute('opacity', new THREE.Float32BufferAttribute(opacities, 1));
	
	        // Use shader material for per-point sizes
	        const mat = new THREE.ShaderMaterial({
	            uniforms: {
	                baseSize: { value: 0.1 }
	            },
	            vertexShader: `
	                attribute float size;
	                attribute vec3 color;
	                attribute float opacity;
	                uniform float baseSize;
	                varying vec3 vColor;
	                varying float vOpacity;
	                
	                void main() {
	                    vColor = color;
	                    vOpacity = opacity;
	                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
	                    gl_PointSize = size * baseSize * (300.0 / -mvPosition.z);
	                    gl_Position = projectionMatrix * mvPosition;
	                }
	            `,
	            fragmentShader: `
	                varying vec3 vColor;
	                varying float vOpacity;
	                
	                void main() {
	                    // Optimized circle calculation - avoid expensive sqrt
	                    vec2 center = gl_PointCoord - 0.5;
	                    float dist2 = dot(center, center);
	                    if (dist2 > 0.25) discard; // 0.25 = 0.5^2
	                    
	                    gl_FragColor = vec4(vColor, vOpacity);
	                }
	            `,
	            transparent: false, // Will be dynamically set based on opacity values
	            depthWrite: true   // Will be set to false when transparent
	        });
	
	        this.points = new THREE.Points(geom, mat);
	        this.colorAttr = geom.getAttribute('color');
	        this.sizeAttr = geom.getAttribute('size');
	        this.opacityAttr = geom.getAttribute('opacity');
	        this.scene.add(this.points);
	
	        if (this.uiManager) this.uiManager.onPointsRegenerated();
	        this._updateColors();
	    }
	
	    handleSettingChange(prop) {
	        if (prop === 'pointSize' || prop === 'opacity') {
	            this.points.material.uniforms.baseSize.value = this.settings.pointSize;
	            this.points.material.needsUpdate = true;
	
	            /* update picking tolerance to roughly match size - using CONFIG */
	            this.raycaster.params.Points.threshold = this.settings.pointSize * CONFIG.interaction.raycastThresholdMultiplier;
	        }
	    }
	
	    /* ---------- recolour all points --------------------------- */
	    _updateColors() {
	        const colorArray = this.colorAttr.array;
	        const sizeArray = this.sizeAttr.array;
	        const opacityArray = this.opacityAttr.array;
	
	        // Check if we need transparency for any points
	        let needsTransparency = false;
	
	        for (let i = 0; i < this.colorAttr.count; ++i) {
	            const attrs = this.selMgr.attrs(i);
	            // Set RGB color values (don't multiply by opacity)
	            colorArray[i * 3] = attrs.r;
	            colorArray[i * 3 + 1] = attrs.g;
	            colorArray[i * 3 + 2] = attrs.b;
	
	            // Set per-point size and opacity
	            sizeArray[i] = attrs.size;
	            opacityArray[i] = attrs.opacity;
	
	            // Check if we need transparency
	            if (attrs.opacity < 0.95) {
	                needsTransparency = true;
	            }
	        }
	
	        // Update material transparency setting
	        if (this.points.material.transparent !== needsTransparency) {
	            this.points.material.transparent = needsTransparency;
	            this.points.material.depthWrite = !needsTransparency; // Disable depth write for transparency
	            this.points.material.needsUpdate = true;
	        }
	
	        this.colorAttr.needsUpdate = true;
	        this.sizeAttr.needsUpdate = true;
	        this.opacityAttr.needsUpdate = true;
	    }
	
	    /* ---------- camera motion - using CONFIG values ---------- */
	    _moveCamera() {
	        const sens = CONFIG.movement.mouseSensitivity;
	        const yaw = -this.mouseDX * sens;
	        const dp = -this.mouseDY * sens;
	
	        if (yaw) {
	            this.camera.rotateY(yaw);
	            // Update CONFIG and debounce URL sync
	            CONFIG.camera.rotation.yaw += yaw;
	            this._debounceCameraSync();
	        }
	        if (dp) {
	            const np = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch + dp));
	            this.camera.rotateX(np - this.pitch);
	            this.pitch = np;
	            // Update CONFIG and debounce URL sync
	            CONFIG.camera.rotation.pitch = this.pitch;
	            this._debounceCameraSync();
	        }
	        this.mouseDX = this.mouseDY = 0;
	
	        if (this.keys['KeyQ']) {
	            this.camera.rotateZ(this.rollSpeed);
	            CONFIG.camera.rotation.roll += this.rollSpeed;
	            this._debounceCameraSync();
	        }
	        if (this.keys['KeyE']) {
	            this.camera.rotateZ(-this.rollSpeed);
	            CONFIG.camera.rotation.roll -= this.rollSpeed;
	            this._debounceCameraSync();
	        }
	
	        this.velocity.set(0, 0, 0);
	        if (this.keys['KeyW']) this.velocity.z -= 1;
	        if (this.keys['KeyS']) this.velocity.z += 1;
	        if (this.keys['KeyA']) this.velocity.x -= 1;
	        if (this.keys['KeyD']) this.velocity.x += 1;
	
	        if (this.velocity.lengthSq()) {
	            const speed = this.settings.speed *
	                (this.keys['ShiftLeft'] ? CONFIG.movement.sprintMultiplier : 1) * 0.016;
	            this.velocity.normalize().multiplyScalar(speed)
	                .applyQuaternion(this.camera.quaternion);
	            this.camera.position.add(this.velocity);
	
	            // Update CONFIG and debounce URL sync
	            CONFIG.camera.position.x = this.camera.position.x;
	            CONFIG.camera.position.y = this.camera.position.y;
	            CONFIG.camera.position.z = this.camera.position.z;
	            this._debounceCameraSync();
	        }
	    }
	
	    /* ---------- render loop ----------------------------------- */
	    _animate() {
	        requestAnimationFrame(() => this._animate());
	
	        this._moveCamera();
	
	        /* picking - skip during touch interactions to improve performance */
	        if (!this.touchState.panDisablesInteraction) {
	            this.raycaster.setFromCamera(this.pointerNDC, this.camera);
	            const hit = this.raycaster.intersectObject(this.points, false)[0];
	            this.hoverId = hit ? hit.index : null;
	
	            if (this.hoverId !== this.prevHoverId) {
	                this.prevHoverId = this.hoverId;
	                this._updateCrosshairs(this.hoverId);
	            }
	        }
	
	        this._updateAllInfoBoxLines();
	        if (this.uiManager) this.uiManager.updateUI();
	        this.renderer.render(this.scene, this.camera);
	    }
	
	    /* ---------- debounced camera sync to URL ----------------- */
	    _debounceCameraSync() {
	        if (this.cameraSyncTimeout) {
	            clearTimeout(this.cameraSyncTimeout);
	        }
	        this.cameraSyncTimeout = setTimeout(() => {
	            updateURL();
	            this.cameraSyncTimeout = null;
	        }, this.cameraSyncDelay);
	    }
	
	    /* ---------- allow UIManager to attach --------------------- */
	    setUIManager(ui) { this.uiManager = ui; }
	}
	</script>
	<!-- end 'PointCloud.js' -->
		<!-- begin 'navball.js' -->
	<script>
	class Navball {
		constructor(containerId, size = null) {
			this.container = document.getElementById(containerId);
			this.size = size || CONFIG.navball.size;
	
			this.yaw = 0;
			this.pitch = 0;
			this.isDragging = false;
			this.lastMouseX = 0;
			this.lastMouseY = 0;
			this.sensitivity = CONFIG.navball.sensitivity;
	
			this.init();
		}
	
		init() {
			this.setupThreeJS();
			this.createNavball();
			this.setupControls();
			this.animate();
		}
	
		setupThreeJS() {
			this.scene = new THREE.Scene();
			this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
			this.camera.position.z = 3;
	
			this.renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			});
			this.renderer.setSize(this.size, this.size);
			this.renderer.setClearColor(0x000000, 0);
			this.renderer.domElement.id = 'navball-canvas';
			this.container.appendChild(this.renderer.domElement);
		}
	
		createNavball() {
			// Low-density wireframe sphere - using CONFIG values
			const geometry = new THREE.SphereGeometry(
				1,
				CONFIG.navball.sphereDetail.widthSegments,
				CONFIG.navball.sphereDetail.heightSegments
			);
			const material = new THREE.MeshBasicMaterial({
				color: 0x004400,
				wireframe: true,
				transparent: true,
				opacity: 0.3
			});
	
			this.navballMesh = new THREE.Mesh(geometry, material);
			this.scene.add(this.navballMesh);
	
			// Axis group
			this.axisGroup = new THREE.Group();
			this.scene.add(this.axisGroup);
	
			this.createAxes();
		}
	
		createAxes() {
			const axisLength = CONFIG.navball.axisLength;
			const arrowLength = CONFIG.navball.arrowLength;
			const arrowRadius = CONFIG.navball.arrowRadius;
	
			const axes = [
				{ name: 'X', color: 0xff4444, direction: [1, 0, 0], rotation: [0, 0, -Math.PI / 2] },
				{ name: 'Y', color: 0x44ff44, direction: [0, 1, 0], rotation: [0, 0, 0] },
				{ name: 'Z', color: 0x4444ff, direction: [0, 0, 1], rotation: [Math.PI / 2, 0, 0] }
			];
	
			this.axisLabels = [];
	
			for (const axis of axes) {
				const [x, y, z] = axis.direction;
	
				// Create axis line
				const line = new THREE.Line(
					new THREE.BufferGeometry().setFromPoints([
						new THREE.Vector3(0, 0, 0),
						new THREE.Vector3(x * axisLength, y * axisLength, z * axisLength)
					]),
					new THREE.LineBasicMaterial({ color: axis.color })
				);
				this.axisGroup.add(line);
	
				// Create arrow head
				const arrow = new THREE.Mesh(
					new THREE.ConeGeometry(arrowRadius, arrowLength, 8),
					new THREE.MeshBasicMaterial({ color: axis.color })
				);
				arrow.position.set(x * axisLength, y * axisLength, z * axisLength);
				arrow.rotation.set(...axis.rotation);
				this.axisGroup.add(arrow);
	
				// Create label
				const midAxisPos = 0.65;
				const label = new THREE.Sprite(
					new THREE.SpriteMaterial({
						map: this.createTextTexture(`+${axis.name}`, `#${axis.color.toString(16).padStart(6, '0')}`),
						transparent: true,
						alphaTest: 0.1
					})
				);
				label.position.set(x * midAxisPos, y * midAxisPos, z * midAxisPos);
				label.scale.set(CONFIG.navball.labelScale, CONFIG.navball.labelScale, 1);
				this.axisGroup.add(label);
				this.axisLabels.push(label);
			}
		}
	
		createTextTexture(text, color) {
			const canvas = document.createElement('canvas');
			canvas.width = 128;
			canvas.height = 128;
			const ctx = canvas.getContext('2d');
	
			ctx.fillStyle = color;
			ctx.font = 'bold 64px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText(text, 64, 64);
	
			return new THREE.CanvasTexture(canvas);
		}
	
		setupControls() {
			this.renderer.domElement.addEventListener('mousedown', (e) => {
				this.isDragging = true;
				this.lastMouseX = e.clientX;
				this.lastMouseY = e.clientY;
				this.renderer.domElement.style.cursor = 'grabbing';
			});
	
			document.addEventListener('mousemove', (e) => {
				if (!this.isDragging) return;
	
				const deltaX = e.clientX - this.lastMouseX;
				const deltaY = e.clientY - this.lastMouseY;
	
				this.yaw += deltaX * this.sensitivity;
				this.pitch += deltaY * this.sensitivity;
				this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
	
				this.lastMouseX = e.clientX;
				this.lastMouseY = e.clientY;
	
				this.updateRotation();
			});
	
			document.addEventListener('mouseup', () => {
				this.isDragging = false;
				this.renderer.domElement.style.cursor = 'grab';
			});
	
			this.renderer.domElement.style.cursor = 'grab';
		}
	
		updateRotation() {
			this.navballMesh.rotation.set(0, 0, 0);
			this.navballMesh.rotateY(this.yaw);
			this.navballMesh.rotateX(this.pitch);
	
			this.axisGroup.rotation.set(0, 0, 0);
			this.axisGroup.rotateY(this.yaw);
			this.axisGroup.rotateX(this.pitch);
		}
	
		animate() {
			requestAnimationFrame(() => this.animate());
			this.renderer.render(this.scene, this.camera);
		}
	
		// API methods for external control
		setRotation(yaw, pitch) {
			this.yaw = yaw;
			this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
			this.updateRotation();
		}
	
		getRotation() {
			return { yaw: this.yaw, pitch: this.pitch };
		}
	
		// Apply inverted camera quaternion to show world orientation from camera perspective
		syncWithCameraQuaternion(quaternion) {
			// Invert the quaternion: q* = (w, -x, -y, -z) for unit quaternions
			const invertedQuaternion = new THREE.Quaternion(
				-quaternion.x,
				-quaternion.y,
				-quaternion.z,
				quaternion.w
			);
	
			// Apply inverted quaternion to show world axes as seen from camera
			this.navballMesh.quaternion.copy(invertedQuaternion);
			this.axisGroup.quaternion.copy(invertedQuaternion);
		}
	}
	</script>
	<!-- end 'navball.js' -->
</head>

<body>
	<div id="container"><!-- single outer container -->
		<div id="shortcuts"></div>
		<!-- ---------- Help menu ---------- -->
		<div id="helpMenu" class="menu">
			<div class="help-section" id="helpInfo">
				<!-- This will be populated from CONFIG.info.help -->
			</div>
			<div class="help-section">
				<h3>Movement</h3>
				<p>WASD - Move around the 3D space</p>
				<p>Mouse - Look around (double-click to lock cursor)</p>
				<p>Q / E - Roll camera left/right</p>
				<p>Shift - Sprint (faster movement)</p>
				<p>ESC - Exit mouse-look mode</p>
			</div>
			<div class="help-section">
				<h3>Panels (press key to toggle)</h3>
				<p>H - This help menu with controls and tips</p>
				<p>M - Main controls menu for adjusting visualization</p>
				<p>I - Info panel showing currently selected data points</p>
				<p>L - Legend panel with color scheme and categories</p>
				<p>N - Navigation panel with 3D compass and position</p>
				<p>J - Performance stats (FPS, render info, camera position)</p>
				<p>K - Toggle hover tooltips when pointing at data points</p>
				<p>B - Toggle click-to-select functionality</p>
				<p>O - Toggle right-click actions for point details</p>
				<p>P - Toggle middle-click info boxes</p>
			</div>
			<div class="help-section">
				<h3>Data Interaction</h3>
				<p>C - Cycle through available color-by columns</p>
				<p>V - Cycle through available selection columns</p>
				<p>Click - Select/deselect point (when click-select enabled)</p>
				<p>Right-click - Open point data/URL (when right-click enabled)</p>
				<p>Middle-click - Create info box for point (when enabled)</p>
				<p>Hover - Show point details tooltip (when hover enabled)</p>
			</div>
			<div class="help-section">
				<h3>Configuration</h3>
				<p>All settings are automatically saved to URL</p>
				<p>Use "Export Current Config" button to get JSON file</p>
				<p>URL parameters override config.json settings</p>
				<p>Use "Reset Config" to return to loaded defaults</p>
			</div>
			<div class="help-section">
				<h3>Source code / report issues:</h3>
				<p><a href="https://github.com/mivanit/js-embedding-vis" style="color: #ffbb00"> github.com/mivanit/js-embedding-vis</a>
			</div>
			<div class="close-hint">Press H to close</div>
		</div>
		<!-- ---------- Enhanced Controls menu ---------- -->
		<div id="controlsMenu" class="menu">
			<!-- Column Selection - Side by Side -->
			<div class="control-section">
				<h4>Column Selection</h4>
				<div class="column-selection">
					<div class="column-item">
						<label>Color by:</label>
						<select id="colorBySelect"></select>
					</div>
					<div class="column-item">
						<label>Select by:</label>
						<select id="selectBySelect"></select>
					</div>
				</div>
				<button id="applyColumns" style="width: 100%; margin-top: 10px;">Apply Column Choice</button>
			</div>
			<!-- Point Configuration - Side by Side -->
			<div class="control-section">
				<h4>Point Configuration</h4>
				<div class="side-by-side">
					<div class="point-config">
						<h5>Selected Points</h5>
						<div class="control-row-new">
							<label>Size: <span class="value-display-right" id="pointSizeValue">6</span></label>
							<div class="slider-container">
								<input id="pointSize" type="range" min="1" max="20" step="1" value="6">
							</div>
						</div>
						<div class="control-row-new">
							<label>Opacity: <span class="value-display-right" id="opacityValue">1.0</span></label>
							<div class="slider-container">
								<input id="opacity" type="range" min="0.1" max="1" step="0.1" value="1.0">
							</div>
						</div>
						<button id="randomizeColors" class="randomize-btn">Randomize Colors</button>
					</div>
					<div class="point-config">
						<h5>Non-Selected Points</h5>
						<div class="control-row-new">
							<label>Size: <span class="value-display-right" id="nonSelPointSizeValue">4</span></label>
							<div class="slider-container">
								<input id="nonSelPointSize" type="range" min="1" max="20" step="1" value="4">
							</div>
						</div>
						<div class="control-row-new">
							<label>Opacity: <span class="value-display-right" id="nonSelOpacityValue">0.25</span></label>
							<div class="slider-container">
								<input id="nonSelOpacity" type="range" min="0.01" max="1" step="0.01" value="0.25">
							</div>
						</div>
						<div class="control-row">
							<label>Color:</label>
							<input id="nonSelColor" type="color" value="#666666">
						</div>
						<div class="control-row">
							<label>Background:</label>
							<input id="bgColor" type="color" value="#000011">
						</div>
					</div>
				</div>
			</div>
			<!-- Movement -->
			<div class="control-section">
				<h4>Movement</h4>
				<div class="control-row-new">
					<label>Speed: <div class="slider-container">
							<input id="speed" type="range" min="1" max="200" step="1" value="50">
						</div>
						<span class="value-display-right" id="speedValue">50</span></label>
					</div>
				</div>
				<!-- Axis Selection - Three Columns -->
				<div class="control-section">
					<h4>Axis Selection</h4>
					<div class="axis-selection">
						<div class="axis-item">
							<label>X-Axis:</label>
							<select id="xAxisSelect"></select>
						</div>
						<div class="axis-item">
							<label>Y-Axis:</label>
							<select id="yAxisSelect"></select>
						</div>
						<div class="axis-item">
							<label>Z-Axis:</label>
							<select id="zAxisSelect"></select>
						</div>
					</div>
					<button id="applyAxes" style="width: 100%; margin-top: 10px;">Apply Axes</button>
				</div>
				<!-- Configuration -->
				<div class="control-section">
					<h4>Configuration</h4>
					<div class="side-by-side">
						<button id="exportConfigBtn" class="export-btn">Export Current Config</button>
						<button id="resetConfigBtn" class="export-btn">Reset Config</button>
					</div>
				</div>
				<div class="close-hint">Press M to close</div>
			</div>
		</div><!-- /#container -->
		<!-- ---------- Info panel (center bottom) - for selected values only ---------- -->
		<div id="infoMenu" class="menu">
			<div id="selectedValuesContainer">
				<h4 style="margin: 0 0 8px 0; color: #00ccff;" id="selectedValuesHeader">Selected Values:</h4>
				<div id="selectedValuesGrid" style="display: grid; grid-template-columns: 1fr; gap: 4px; max-height: 200px; overflow-y: auto;"></div>
				<div id="selectedValuesMetadata" style="margin-top: 8px; font-size: 10px; color: #888;"></div>
			</div>
			<div class="close-hint">Press I to close</div>
		</div>
		<!-- ---------- Legend panel (bottom left) - for color scheme and settings ---------- -->
		<div id="legendMenu" class="menu">
			<div id="columnInfoContainer">
				<h4 style="margin: 0 0 8px 0; color: #00ccff;">Current Settings:</h4>
				<div style="font-size: 11px; margin-bottom: 10px;">
					<div>Color by: <span id="currentColorBy" style="color: #00ff00;"></span></div>
					<div>Select by: <span id="currentSelectBy" style="color: #00ff00;"></span></div>
				</div>
			</div>
			<div id="legendContainer">
				<h4 style="margin: 0 0 8px 0; color: #00ccff;" id="legendHeader">Legend:</h4>
				<div id="legendGrid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; max-height: 200px; overflow-y: auto;"></div>
				<div id="legendMetadata" style="margin-top: 8px; font-size: 10px; color: #888;"></div>
			</div>
			<div class="close-hint">Press L to close</div>
		</div>
		<!-- ---------- Stats menu ---------- -->
		<div id="statsMenu" class="menu">
			<div class="stats-group">
				<h3>Rendering Stats</h3>
				<p>Points Rendered: <span id="renderedCount">0</span></p>
				<p>FPS: <span id="fps">na</span></p>
				<p>Frame Time: <span id="frameTime">na</span></p>
			</div>
			<div class="stats-group">
				<h3>Camera Position</h3>
				<p>X: <span id="statsPosX">na</span></p>
				<p>Y: <span id="statsPosY">na</span></p>
				<p>Z: <span id="statsPosZ">na</span></p>
			</div>
			<div class="close-hint">Press J to close</div>
		</div>
		<!-- ---------- Navigation bar with navball ---------- -->
		<div id="navbar" class="menu">
			<div id="navball-container">
				<div class="navball-crosshair"></div>
			</div>
			<div class="nav-section">
				<h4>Position</h4>
				<div class="nav-row">
					<span>X: <span id="posX">0.0</span></span>
					<span>Y: <span id="posY">0.0</span></span>
					<span>Z: <span id="posZ">0.0</span></span>
				</div>
			</div>
		</div>
		<!-- ---------- bootstrap script ---------- -->
		<script>
			document.addEventListener('DOMContentLoaded', async () => {
				let sp = NOTIF.spinner('Starting up...');
				await getConfig();

				// Update page title from config
				document.title = CONFIG.info.title;

				// Update help info section
				const helpInfoEl = document.getElementById('helpInfo');
				if (helpInfoEl && CONFIG.info.help) {
					helpInfoEl.innerHTML = `<p>${CONFIG.info.help}</p>`;
				}

				const model = await DataModel.load(CONFIG.dataFile, CONFIG.numericalPrefix);
				const pointCloud = new PointCloud(model);
				const uiManager = new UIManager(pointCloud);
				pointCloud.setUIManager(uiManager);
				sp.complete();
				NOTIF.success('Ready! Press H for help.');
			});
		</script>
		<!-- Info box containers for middle-click functionality -->
		<svg id="info-box-lines"></svg>
		<div id="info-boxes"></div>
</body>

</html>